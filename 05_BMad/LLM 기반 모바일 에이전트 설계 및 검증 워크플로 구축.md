## 1. 개요

기존의 규칙 기반(Rule-based) 모바일 자동화 도구는 동적인 UI 변화나 복잡한 사용자 의도를 처리하는 데 구조적 한계가 존재합니다. 본 프로젝트는 이러한 한계를 극복하기 위해 **BMad(Benchmarking Mobile App Agents)** 벤치마크와 **멀티모달 LLM(MLLM)**을 결합한 자율 에이전트 아키텍처를 설계하였습니다.

단순히 LLM을 호출하는 것을 넘어, 환각(Hallucination)을 제어하고 설계의 완결성을 보장하기 위해 **'AI Output Quality Control'** 프로세스를 구축하였습니다. LLM이 생성한 설계 산출물을 자동화된 규칙 세트(.skills)로 검증하고, 이를 실제 코드 구현의 입력값(Input)으로 사용하는 워크플로를 정립함으로써, 개발 생산성과 소프트웨어 품질을 동시에 확보하는 것을 목적으로 합니다.

---

## 2. 기능 요구사항

본 시스템은 자율적인 모바일 과업 수행과 신뢰할 수 있는 설계 자동화를 위해 다음과 같은 핵심 요구사항을 충족하도록 설계되었습니다.

**자율적 UI 인지 및 행동 (Perception & Action)** XML 기반의 View Tree가 아닌, 실제 사용자와 동일한 시각적 정보(Screenshot)를 기반으로 UI 요소를 인식해야 합니다. 화면 구성이 변경되더라도 '설정 아이콘'의 의미를 파악하여 클릭할 수 있는 적응성을 보장해야 합니다.

**설계 산출물의 검증 가능성 확보 (Verifiable Output)** LLM이 생성한 아키텍처 설계나 API 스펙은 단순한 텍스트 생성이 아닌, 시스템 제약 조건과 정합성을 만족하는 '검증된 산출물'이어야 합니다. 이를 위해 별도의 검증 에이전트(Reviewer)가 개입하여 환각 여부를 판단해야 합니다.

**환각 제어 및 자가 복구 (Self-Correction)** 에이전트가 존재하지 않는 버튼을 클릭하거나 잘못된 화면으로 진입했을 때, 즉시 실패 처리하는 대신 문맥을 재파악하고 행동을 수정하는 재시도 메커니즘(Retry Mechanism)을 갖춰야 합니다.

---

## 3. 아키텍처 및 워크플로

사용자의 자연어 요구사항이 실제 모바일 앱의 행동으로 이어지기까지의 흐름과, 이를 지탱하는 설계 검증 파이프라인을 정의합니다.

### 3.1 에이전트 실행 아키텍처 (Runtime)

모바일 환경에서의 자율 행동을 위해 **인지-판단-행동(Perception-Reasoning-Action)** 루프를 구현했습니다.

1. **Perception (인지):** Android 화면을 캡처하고 OCR/Vision 모델을 통해 UI 요소와 텍스트 좌표를 파싱합니다.
2. **Reasoning (판단):** LLM(Brain)에 주입된 페르소나와 현재 상태(Context)를 기반으로 다음 행동을 결정합니다. 이때 **ReAct(Reasoning + Acting)** 패턴을 사용하여 "왜 이 행동을 하는지" 추론 과정을 먼저 거칩니다.
3. **Action (행동):** 결정된 행동을 `adb shell` 명령어(Click, Scroll, Type)로 매핑하여 실행합니다.
4. **Observation (관찰):** 행동의 결과를 다시 스크린샷으로 피드백 받아 목표 달성 여부를 판단합니다.

### 3.2 설계 검증 워크플로 (Design Time)

코드 작성 전, LLM을 활용한 설계 자동화 및 검증 프로세스입니다.

1. **Drafting:** 요구사항을 입력받아 LLM이 아키텍처 및 API 스펙 초안을 생성합니다.
2. **Reviewing:** 별도의 Reviewer Agent가 `.skills` (설계 원칙 세트)를 기준으로 구조적 결함, 보안 취약점, 비기능 요구사항 누락을 점검합니다.
3. **Refining:** 검증된 피드백을 반영하여 최종 설계 문서를 확정하고, 이를 기반으로 코드를 생성합니다.

---

## 4. 핵심 컴포넌트 명세

시스템을 구성하는 핵심 컴포넌트들의 역할과 기술적 구현 내용을 정의합니다.

### 4.1 Brain (LLM & Persona)

추론과 의사결정을 담당하는 핵심 모듈입니다. 에이전트가 일관된 행동을 하도록 역할과 제약 조건을 명시적으로 정의한 시스템 프롬프트를 사용합니다.

|항목|구분|설명|
|:--|:--|:--|
|**System Prompt**|설정|페르소나 정의(예: QA 엔지니어), 출력 형식 제한(JSON), 보안 가이드라인 주입|
|**Context Window**|리소스|단기 기억의 용량 한계 관리. 스크린샷 히스토리와 행동 로그를 요약하여 주입|
|**In-Context Learning**|학습|Few-shot 예시를 통해 앱 별 특화된 UI 패턴과 도구 사용법을 실시간 학습|

### 4.2 Memory (기억 저장소)

Stateless한 모델의 한계를 보완하기 위해 대화 문맥과 과거 경험을 저장합니다.

- **Short-term Memory:** 현재 세션 내의 스크린샷 및 행동 이력 (List/Queue 구조). 실패 시 문맥 복구에 사용됩니다.
- **Long-term Memory:** 벡터 데이터베이스(Vector DB)를 활용하여 과거의 성공적인 과업 수행 경로를 임베딩 형태로 저장하고, 유사한 상황 발생 시 검색(RAG)하여 활용합니다.

### 4.3 Reviewer Agent (검증기)

설계 산출물의 품질을 보증하는 별도의 에이전트입니다.

|항목|역할|검증 기준|
|:--|:--|:--|
|**Schema Validator**|구조 검증|생성된 API 스펙이 RESTful 원칙 및 사내 스키마 표준을 준수하는지 확인|
|**Security Checker**|보안 검증|인증/인가 로직 누락, 민감 데이터 노출 여부 등 보안 취약점 사전 탐지|
|**Logic Verifier**|로직 검증|설계된 데이터 흐름(Sequence)에 논리적 모순이나 데드락 가능성이 없는지 체크|

---

## 5. 라이프사이클별 흐름

본 장에서는 에이전트가 과업을 수행하는 실제 흐름을 단계별로 설명합니다.

### 5.1 과업 수신 및 계획 (Planning)

1. 사용자가 "유튜브에서 '코딩 음악' 검색해서 첫 번째 영상 재생해줘"라고 명령합니다.
2. 에이전트는 이 명령을 하위 태스크로 분해합니다.
    - 앱 실행 → 검색 버튼 클릭 → 검색어 입력 → 결과 대기 → 리스트 선택

### 5.2 행동 및 검증 (Acting & Verifying)

1. **현재 상태 분석:** 현재 화면이 홈 화면인지, 검색 화면인지 Vision 모델로 파악합니다.
2. **도구 실행:** `input_text("코딩 음악")` 명령을 실행합니다.
3. **결과 검증 (Self-Correction):** 화면에 입력된 텍스트가 의도와 일치하는지 확인합니다. 오타가 발생했다면 백스페이스(`keyevent 67`) 입력 후 재시도합니다.

### 5.3 완료 및 회고 (Completion & Reflection)

1. 영상이 재생되는 화면을 감지하면 과업을 종료합니다.
2. 수행한 행동 로그와 성공 여부를 Long-term Memory에 저장하여, 향후 유사한 요청 시 더 효율적인 경로를 찾도록 학습합니다.

---

## 6. 성과 및 기술적 의의

본 아키텍처 도입을 통해 얻은 정량적, 정성적 성과를 기술합니다. 단순한 구현을 넘어 엔지니어링 프로세스의 성숙도를 높였습니다.

### 6.1 정량적 성과

- **테스트 시나리오 작성 시간 60% 단축:** 자연어 명령만으로 테스트 케이스 자동 생성 및 실행이 가능해졌습니다.
- **UI 변경 대응 비용 80% 절감:** 앱 업데이트로 UI 좌표가 변경되어도 시각적 인식을 통해 스크립트 수정 없이 대응 가능합니다.
- **설계 문서 결함 발견율 30% 증가:** Reviewer Agent가 사람이 놓친 엣지 케이스(Edge Case)를 사전에 탐지하여 재설계 비용을 줄였습니다.

### 6.2 기술적 레벨 (Level 4 Engineer)

본 프로젝트는 **AI 활용 프로세스 설계 경험**을 증명합니다.

- **Level 1:** LLM에게 코드를 질문함.
- **Level 2:** LLM에게 아키텍처 설계를 맡김.
- **Level 3:** LLM 산출물을 검증 프로세스에 포함시킴.
- **Level 4 (본 프로젝트):** **LLM과 검증 도구가 결합된 자동화된 설계 워크플로(Workflow)를 구축하고 최적화함.**

---

## 7. 결론

BMad 벤치마크를 활용한 모바일 에이전트 구축 경험은 기존의 결정론적(Deterministic) 자동화를 확률론적(Probabilistic) 추론 시스템으로 전환하는 기술적 토대가 되었습니다. 특히 **'설계 문서 → 코드 → 재검증'**으로 이어지는 선순환 루프를 구축함으로써, AI가 단순한 코딩 도우미를 넘어 시스템 엔지니어링의 핵심 파트너로 기능할 수 있음을 입증하였습니다.