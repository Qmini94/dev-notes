# 경력기술서 항목 50선 — 박규민 (주)유비

> 회사별 요구사항에 맞게 **선별 조합**하여 제출할 것.
> 각 항목: 배경/문제 → 기술 선택 이유 → 적용 방법 → 성과 (+ Trouble Shooting / Trade-off)

---

## A. 아키텍처 설계 (Architecture)

### A-01. Spring Boot 기반 레거시 CMS 리빌딩 아키텍처 설계

JSP + eGovFrame 3.x 기반 레거시 CMS를 Spring Boot 2.7 + Nuxt 3 구조로 리빌딩했습니다. 기존 시스템은 서버 렌더링 단일 모놀리스로, 프론트·백 분리가 불가능하고 배포 시 전체 서비스 중단이 필요했습니다. eGovFrame 4.2 호환성을 유지하면서 REST API + SPA 아키텍처로 전환하여, 프론트엔드와 백엔드의 독립 배포를 가능하게 했습니다. 기존 eGov 라이브러리(EgovBizException, TraceHandler 등)는 래퍼 클래스로 격리하여 점진적 탈의존이 가능하도록 설계했습니다.

---

### A-02. 멀티사이트 아키텍처 설계

단일 CMS 인스턴스에서 복수의 독립 사이트를 운영해야 하는 요구사항이 있었습니다. 사이트별로 메뉴 트리, 콘텐츠, 권한, 레이아웃이 모두 독립적이어야 했습니다. `hostname` 기반 사이트 식별자를 도입하고, 모든 API 요청에 `X-Site-Hostname` 헤더를 주입하여 사이트 컨텍스트를 전달했습니다. 백엔드의 Site 엔티티에 `siteName`, `siteHostName`, `isOpen`, `allowIp`, `denyIp` 필드를 정의하고, SiteAccessChecker가 CIDR 표기법을 포함한 IP 기반 접근 제어를 수행합니다. 프론트엔드에서는 siteStore가 활성 사이트 목록을 관리하고, 레이아웃 미들웨어(`05.layout-selector.ts`)가 사이트명을 slugify하여 `{prefix}-main`, `{prefix}-sub` 레이아웃을 자동 선택합니다.

---

### A-03. Hexagonal 아키텍처 지향 포트-어댑터 패턴 적용

외부 시스템(SSO, 폐쇄망 연동) 의존성을 비즈니스 로직에서 분리하기 위해 포트-어댑터 패턴을 적용했습니다. 예를 들어, `SiteAccessChecker`는 인터페이스(포트)로 정의하고 `SiteAccessCheckerImpl`이 `application.yml`의 `cms.allowed-ips`를 읽어 CIDR 매칭을 수행하는 어댑터로 구현했습니다. 이 구조를 통해 SSO 연동 방식 변경, IP 정책 변경 등 외부 의존성 교체 시 비즈니스 로직 수정 없이 어댑터만 교체할 수 있습니다.

---

### A-04. 통합 API 응답 규격 설계 (ApiResponse\<T\>)

API 응답 포맷이 엔드포인트마다 상이하여 프론트엔드에서 에러 처리가 일관되지 않는 문제가 있었습니다. `ApiResponse\<T\>` 제네릭 래퍼 클래스를 도입하여 `success(data)`, `error(code, message)` 두 가지 팩토리 메서드로 전체 API 응답을 통합했습니다. `GlobalExceptionHandler`에서 400/401/403/404/409/413/500 각 HTTP 상태별로 `ApiResponse\<Void\>`를 반환하도록 매핑하여, 프론트엔드의 `safeFetch` 유틸리티가 단일 에러 처리 로직으로 모든 API를 커버할 수 있게 되었습니다.

---

### A-05. 프로파일 기반 환경 분리 설계

`application.yml`(공통) + `application-local.yml`(로컬) + `application-prod.yml`(운영)로 설정을 분리하고, `SPRING_PROFILES_ACTIVE` 환경변수만으로 환경을 전환하도록 구성했습니다. 기존에는 설정 파일 내 주석 토글 방식이었으나, 이를 제거하고 프로파일 기반으로 전환하여 잘못된 설정 배포를 방지했습니다. Docker `.env` 파일과 `switch-env.sh` 스크립트로 로컬/원격 DB 전환을 단일 명령으로 수행합니다.

---

### A-06. 이벤트 기반 느슨한 결합 구조 설계

CMS CRUD 작업과 검색 색인 동기화 간의 강결합을 해소하기 위해 Spring Events + Transactional Outbox 패턴을 조합했습니다. 콘텐츠 변경 시 `IndexingEvent`를 발행하고, `@TransactionalEventListener`가 동일 트랜잭션 내에서 `cms_search_outbox` 테이블에 이벤트를 기록합니다. `@Async IndexingEventListener`가 비동기로 Elasticsearch에 색인을 수행하며, 실패 시 `OutboxPollingService`가 주기적으로 재시도합니다. CMS 코어 서비스에는 이벤트 발행 한 줄만 추가되어 관심사가 완전히 분리됩니다.

---

## B. 백엔드 보안 (Security)

### B-01. JWT + HttpOnly Cookie 기반 인증 시스템 구현

Spring Security 필터 체인에 JWT 인증 필터(`JwtAuthenticationFilter`)를 등록하고, ACCESS/REFRESH 이중 토큰 구조를 구현했습니다. 토큰은 HttpOnly + Secure + SameSite 쿠키로 전달하여 XSS를 통한 토큰 탈취를 방지합니다. `AuthCookieUtil`이 쿠키 설정을 관리하며, `X-Session-Expires` 응답 헤더를 통해 프론트엔드의 자동 로그아웃 타이머를 제어합니다.

---

### B-02. Pbkdf2 기반 비밀번호 해싱

`Pbkdf2PasswordEncoder`를 185,000 iterations, 256bit 출력으로 설정하여 NIST 권장 수준의 비밀번호 해싱을 적용했습니다. BCrypt 대비 PBKDF2를 선택한 이유는 eGovFrame 호환성과 KISA 보안 가이드라인 준수 때문입니다.

- **Trade-off**: BCrypt의 adaptive cost factor 대비 PBKDF2는 GPU 병렬 공격에 상대적으로 취약하나, iteration 수를 충분히 높여 보완했습니다.

---

### B-03. AES-GCM 기반 개인정보 암호화 (JPA Converter)

`Member` 엔티티의 전화번호, 이메일, 주소 필드에 `@Convert(converter = StringCryptoConverter.class)`를 적용하여 DB 저장 시 자동 암호화합니다. `CryptoUtil`은 AES/GCM/NoPadding 알고리즘, 12바이트 IV, 128비트 인증 태그를 사용하며, 암호키는 `/data/egovframe-cms/install/crypto_key/crypto.key`에서 hex 포맷으로 로드합니다. Docker 환경에서는 `crypto_key` 디렉토리를 read-only 볼륨으로 마운트하여 키 파일의 변조를 방지합니다.

---

### B-04. HTML Sanitization AOP를 활용한 XSS 방어

`@SanitizeHtml` 커스텀 어노테이션과 `HtmlSanitizerAspect` AOP를 구현하여, `@Transactional` 메서드 진입 시 DTO의 HTML 필드를 자동 정제합니다. `HtmlSanitizerUtil`은 `<script>`, `javascript:`, `vbscript:`, `on*=` 이벤트 핸들러, CSS `expression()`, `<iframe>`, `<form>`, `<object>` 등을 제거합니다. 프론트엔드에서도 `SafeHtml.vue` 컴포넌트가 isomorphic-dompurify로 렌더링 시점에 이중 방어합니다.

---

### B-05. IP 기반 접근 제어 (CIDR 지원)

사이트별 `allowIp`/`denyIp` 정책을 `SiteAccessCheckerImpl`에서 CIDR 표기법(`172.16.0.0/12`)으로 처리합니다. 프론트엔드 미들웨어 `01.ip-access-guard.ts`에서 SSR 단계에 `X-Forwarded-For` 헤더로 클라이언트 IP를 추출하고, 차단 시 `__ipBlock=1` 쿠키를 설정하여 CSR에서도 동일 차단을 유지합니다. `IpUtil` 유틸리티가 IP 파싱과 CIDR 매칭을 수행합니다.

---

### B-06. 계층형 권한 모델 및 Redis 캐싱

메뉴별 권한을 `userIdx`(개인) + `userLevel`(역할) 이중 기준으로 해소합니다. `PermissionResolverService`가 `MenuPermissionData`를 Redis에 캐싱하여, 개인 권한이 있으면 우선 적용하고 없으면 레벨 권한으로 fallback합니다. `RedisConfig`에서 `GenericJackson2JsonRedisSerializer`를 사용한 JSON 직렬화를 적용하여 Redis 데이터의 가독성을 확보했습니다. 권한 조회 시 재귀 탐색을 제거하고 단일 쿼리로 해소하여 응답 속도를 10배 이상 개선했습니다.

---

### B-07. Swagger/OpenAPI IP 제한 접근 설정

운영 환경에서 API 문서 노출을 방지하기 위해, Nginx 설정에서 `/swagger-ui/`, `/v3/api-docs` 경로에 IP 화이트리스트(사내 IP만 allow, 나머지 deny all)를 적용했습니다. 개발 환경에서는 `SwaggerConfig`를 통해 전체 API 스펙을 자동 생성합니다.

---

### B-08. CORS 및 CSRF 정책 설정

REST API는 Stateless 특성상 CSRF를 비활성화하고, CORS 허용 오리진을 프로파일별로 관리합니다. `SecurityConfig`에서 `http.cors().and().csrf().disable()`로 API에 대한 CSRF를 해제하되, 쿠키 인증 방식이므로 SameSite=Strict 쿠키 속성으로 CSRF를 대체 방어합니다.

---

## C. 데이터 접근 전략 (Data Access)

### C-01. JPA + QueryDSL 조합의 CRUD 도메인 구현

조직도·게시판 마스터·사이트 등 CRUD 중심 도메인에 JPA + QueryDSL을 적용했습니다. `JPAQueryFactory`를 Bean으로 등록하고, Repository 인터페이스에 QueryDSL의 타입 안전 쿼리를 조합하여 동적 조건 검색을 구현했습니다. `BoardMasterCacheService`에서 `@Cacheable`로 게시판 설정을 `ConcurrentMapCacheManager` 인메모리 캐시에 저장하여 반복 조회 성능을 개선했습니다.

---

### C-02. JDBC 기반 동적 보드 CRUD

30종 이상의 게시판 유형을 지원하기 위해, 게시판마다 동적으로 테이블이 생성되는 구조를 구현했습니다. `DynamicBoardServiceImpl`이 `BoardFieldDefinition` 메타데이터를 기반으로 INSERT/SELECT/UPDATE/DELETE SQL을 런타임에 조합합니다. JPA 엔티티 매핑이 불가능한 동적 테이블이므로 JDBC를 선택했습니다.

---

### C-03. JDBC Template 기반 런타임 DDL 엔진

관리자가 웹 UI에서 게시판 필드를 추가·수정·삭제하면, `BoardMasterServiceImpl`이 `ALTER TABLE` DDL을 동적 생성·실행합니다. `BoardFieldDefinitionsUpsertRequest`로 필드 메타(컬럼명, 타입, 필수 여부)를 수신하고, SQL Injection 방지를 위해 컬럼명·타입에 대한 화이트리스트 검증을 수행합니다. 스키마 변경 이력은 `BoardMasterSnapshot`으로 기록하여 롤백이 가능합니다.

---

### C-04. MapStruct 기반 DTO-Entity 자동 매핑

9개의 MapStruct 매퍼(`BoardMasterMapper`, `ContentMapper`, `MenuMapper`, `MemberMapper`, `SiteMapper` 등)를 통해 DTO ↔ Entity 변환을 컴파일 타임에 생성합니다. 리플렉션 기반 매핑(ModelMapper) 대비 성능이 우수하고, 컴파일 시 매핑 오류를 감지할 수 있어 런타임 에러를 방지합니다. `@Mapping` 어노테이션으로 필드명이 다른 경우의 명시적 매핑도 처리합니다.

---

### C-05. Redis 세션 + 인메모리 캐시 이중 캐싱 전략

Redis는 세션 관리(`sessionRedisTemplate`)와 권한 캐시(`redisTemplate`)에 사용하고, 게시판 마스터 설정처럼 변경 빈도가 낮은 데이터는 `ConcurrentMapCacheManager` 인메모리 캐시를 사용합니다. `RedisHealthChecker`가 주기적으로 Redis 상태를 확인하고, 장애 시 JWT TTL을 연장하여 서비스 가용성을 유지합니다.

---

### C-06. JPA Auditing 기반 자동 일시 기록

`@EnableJpaAuditing` + `@CreatedDate` / `@LastModifiedDate` 어노테이션으로 엔티티의 생성·수정 일시를 자동 기록합니다. 별도의 서비스 로직 없이 JPA 이벤트 리스너가 처리하여 코드 중복을 제거했습니다.

---

## D. Elasticsearch 검색 (Search)

### D-01. Nori 한국어 분석기 기반 풀텍스트 검색 구현

MySQL LIKE 검색의 한계(형태소 분석 불가, 대량 데이터 성능 저하)를 해결하기 위해 Elasticsearch 7.17 + Nori 분석기를 도입했습니다. `IndexSetupServiceImpl`이 Nori 분석기 설정을 포함한 커스텀 인덱스를 생성하고, `ContentDocument`의 `@Document(createIndex = false)` 설정으로 Spring Data 자동 생성을 비활성화했습니다.

---

### D-02. BM25 알고리즘 기반 검색 랭킹 및 필드 부스팅

`SearchService`에서 `multi_match` 쿼리로 `title^2`(제목 가중치 2배) + `body` 필드를 대상으로 BM25 랭킹 검색을 수행합니다. 이를 통해 제목에 검색어가 포함된 결과가 상위에 노출되어 검색 품질을 향상시켰습니다.

---

### D-03. Circuit Breaker 기반 검색 서비스 장애 격리

`SearchService.search()` 메서드에 Resilience4j `@CircuitBreaker`를 적용하여, Elasticsearch 장애 시 503 응답을 반환하는 fallback 메서드로 전환됩니다. 프론트엔드의 `SearchServiceDown.vue` 컴포넌트가 "검색 서비스를 일시적으로 사용할 수 없습니다" 메시지를 표시하며, CMS 핵심 기능(콘텐츠 작성·조회)은 영향 없이 동작합니다. Half-open 상태에서 자동 복구를 시도합니다.

---

### D-04. 2단계 권한 필터링 검색 (Index-time + Query-time)

검색 결과의 권한 누출(존재 자체가 노출)을 방지하기 위해 이중 필터링을 설계했습니다. 1단계: ES 쿼리에서 `visibility=PUBLIC` 필터로 비공개 콘텐츠를 제외합니다. 2단계: `PermissionResolverService.hasPermissionForMenu()`로 각 결과의 메뉴 접근 권한을 검증하고, 권한 없는 결과를 제거합니다. `PERMISSION_FETCH_BUFFER = 2x`로 충분한 후보를 가져와 정확한 페이지네이션을 유지합니다.

---

### D-05. Zero-Downtime 재색인 (Alias Swap)

인덱스 매핑 변경이나 전체 재색인 시 서비스 중단 없이 처리하기 위해 Read/Write Alias Swap 전략을 구현했습니다. 새 인덱스(`cms_content_v{n+1}`)를 생성하고 배치 색인을 수행하는 동안, 기존 인덱스는 Read Alias를 통해 검색 서비스를 계속 제공합니다. 완료 후 Alias를 원자적으로 전환하여 다운타임 없이 새 인덱스로 전환합니다.

---

### D-06. Transactional Outbox 패턴 기반 색인 동기화

`SearchOutbox` 엔티티(status: PENDING/COMPLETED/FAILED, retry_count, contentType, contentIdx, action)를 통해 색인 이벤트를 트랜잭션 내에서 안전하게 기록합니다. 비동기 처리가 실패해도 Outbox 레코드가 남아 있으므로 `OutboxPollingService`가 주기적으로 재시도합니다. 최대 3회 재시도 후 FAILED 처리하고 로그를 남겨 수동 복구가 가능합니다.

---

### D-07. Elasticsearch 배치 색인 및 초기 셋업 API

`POST /search/admin/setup` API로 최초 인덱스 생성 + Nori 분석기 매핑 + 전체 데이터 배치 색인을 수행합니다. `BatchIndexDao`가 JDBC로 동적 게시판 테이블에서 데이터를 추출하고, `IndexingService`가 500건 단위로 Bulk API를 호출하여 대량 데이터를 효율적으로 색인합니다. 이후 증분 동기화는 `/reindex` API를 사용합니다.

- **Trouble Shooting**: date 필드 정렬 시 `missing` 값을 문자열로 설정하여 타입 불일치 에러가 발생했습니다. Elasticsearch date 필드의 `missing` 값은 epoch millis(Long)여야 한다는 것을 확인하고 수정했습니다. range 쿼리에서는 `.format()`을 명시해야 다중 날짜 포맷을 지원합니다.

---

## E. 프론트엔드 (Frontend)

### E-01. Nuxt 3 SSR/CSR 하이브리드 렌더링 전략

Nuxt 3 기반으로 기본 SSR을 활성화하되, 관리자 페이지(`/business/*`)는 인증 필수이므로 CSR 최적화에 집중했습니다. `init.server.ts` 플러그인에서 정적 리소스 경로(`/contents/`, `/uploads/`, `/_nuxt/`)를 정규식으로 감지하여 SSR 초기화를 스킵하고, 운영 환경에서는 Apache/Nginx가 직접 서빙하므로 이 플러그인은 가드 역할만 합니다.

---

### E-02. 5계층 미들웨어 파이프라인 설계

SSR/CSR 하이브리드 환경에서 실행 순서가 보장되는 5계층 미들웨어를 설계했습니다: `01.ip-access-guard` → `02.auth-guard` → `03.menu-management` → `04.render-permission` → `05.layout-selector`. 각 미들웨어는 단일 책임을 수행하며, SSR에서 계산한 정보(IP 차단 여부, 권한)를 쿠키나 `useState()`로 CSR에 전달합니다. redirect loop 방지를 위해 SSR에서 1회성 플래그를 사용합니다.

---

### E-03. safeFetch API 레이어 구현

`ofetch` 래퍼인 `safeFetch`(360+ lines)를 구현하여 전체 API 호출을 통합 관리합니다. 주요 기능: 클라이언트 인메모리 캐시, `X-Menu-Id`/`X-Site-Hostname` 헤더 자동 주입, `X-Session-Expires` 기반 자동 로그아웃 타이머, 401/403 통합 인증 게이트(중복 팝업 방지), 요청별 타임아웃(SSR 7초 / CSR 2.5초), 실패 시 defaultValue fallback.

---

### E-04. TanStack Vue Query 기반 데이터 캐싱

Vue Query를 `staleTime: Infinity`, `retry: 0`, `gcTime: 5분`으로 설정하여 명시적 무효화 전까지 캐시를 유지합니다. 자동 refetch를 모두 비활성화(`refetchOnWindowFocus/Reconnect/Mount: false`)하여, CMS 관리 화면의 예측 가능한 데이터 흐름을 보장합니다.

---

### E-05. Pinia 기반 상태 관리 설계

6개의 Pinia 스토어를 설계했습니다: `userStore`(인증), `menuStore`(메뉴 트리), `renderStore`(렌더 메타데이터), `searchStore`(검색), `siteStore`(사이트 설정), `uiStore`(반응형 UI). `pinia-plugin-persistedstate`로 localStorage 자동 영속화를 적용하고, `authBus`를 통한 크로스탭 인증 동기화(BroadcastChannel + localStorage fallback)를 구현했습니다.

---

### E-06. 동적 게시판 테마 렌더링 엔진

`[...slug].vue` catch-all 라우터에서 `renderStore.type`에 따라 `<Board>` 또는 `<Content>`를 `defineAsyncComponent()`로 코드 스플리팅하여 로드합니다. `Board.vue`는 게시판 유형별 테마 컴포넌트(`theme/list/default/`, `theme/searchBox/`, `theme/pagination/`)를 동적으로 조합하여 list/view/write 모드를 렌더링합니다. 메뉴 ID + 렌더 데이터 기반 컴포넌트 키로 캐시 충돌을 방지합니다.

---

### E-07. 프론트엔드 구조화 로깅 시스템

`logger.ts`(280+ lines) 싱글턴 로거를 구현했습니다. 버퍼 기반(최대 1000건), 비동기 서버 전송, 로그 레벨(debug/info/warn/error), 컨텍스트 자동 캡처(userId, sessionId, userAgent, URL, IP), `startTimer()` 성능 측정. 운영 환경에서는 `console.log/debug`를 noop으로 교체하고, `warn/error`만 로거로 리다이렉트합니다.

---

### E-08. 타입 안전 UI 메시지 시스템

`uiMessages.ko.ts`에 한국어 메시지 딕셔너리를 `Record<UiMessageKey, string>` 타입으로 정의하고, `formatUiMessage(key, params)`가 `{fieldName}` 플레이스홀더를 치환합니다. 타입스크립트 키 타입으로 오타를 컴파일 타임에 감지하며, SSR에서 CSR로 메시지를 전달할 때는 `msg` 쿼리 파라미터를 통해 `ssr-msg.client.ts` 플러그인이 처리합니다.

---

### E-09. 크로스탭 인증 동기화 (BroadcastChannel)

`authBus.ts`(110 lines)가 BroadcastChannel API(우선) + localStorage storage 이벤트(fallback)를 통해 탭 간 LOGIN/LOGOUT/PROFILE_UPDATED 이벤트를 동기화합니다. 고유 TAB_ID로 자기 메시지를 필터링하여 에코를 방지합니다. 한 탭에서 로그아웃하면 모든 탭이 즉시 로그아웃 상태로 전환됩니다.

---

### E-10. 입력 검증 및 파일 유효성 검사

`validator.ts`(160+ lines)에 `ValidationType`별 검증(default 50자, text 1000자, html 10000자, email, phone, url)을 구현했습니다. `sanitizeHtml()`은 isomorphic-dompurify 기반으로 허용 태그/속성을 화이트리스트로 제한합니다. `fileValidator.ts`는 파일 타입/크기를 검증하여 악성 파일 업로드를 방지합니다.

---

## F. 웹 접근성 & UX (Accessibility)

### F-01. KWCAG 2.2 준수 통합 검색 UI

검색 페이지(`/common/search.vue`, 870+ lines)에 웹 접근성을 전면 적용했습니다: `<form role="search">`, `<nav role="navigation">`, 모든 필터 그룹에 `aria-label`/`aria-labelledby`, 결과 영역에 `aria-live="polite"`, 검색 후 `nextTick()` 포커스 이동, `role="status"` 동적 결과 수 표시, `.sr-only` 스크린 리더 전용 텍스트, 키보드 네비게이션(Tab/Enter/Arrow), 페이지네이션 `aria-current="page"`.

---

### F-02. 반응형 레이아웃 및 디바이스 대응

`@nuxtjs/device` 모듈과 `uiStore.isMobile` 상태로 디바이스를 감지하고, Tailwind CSS 반응형 클래스로 모바일/태블릿/데스크톱 레이아웃을 처리합니다. 검색 결과는 섹션 뷰(전체 타입) / 플랫 리스트 뷰(타입 선택)를 전환하며, 모바일에서는 사이드바를 토글 방식으로 변경합니다.

---

### F-03. 다크모드 지원

`@nuxtjs/color-mode` 모듈과 `ColorModeToggle.vue` 컴포넌트로 라이트/다크 모드 전환을 구현했습니다. Element Plus의 `dark/css-vars.css`를 import하고, Tailwind CSS dark variant와 연동하여 전체 UI가 일관되게 전환됩니다.

---

## G. DevOps & 인프라 (Infrastructure)

### G-01. Docker Compose 멀티컨테이너 개발환경

MySQL 8.0 + Redis 7 + Elasticsearch 7.17(커스텀 Nori) + Nginx 1.25 + Spring Boot(Gradle) + Nuxt 3(Node 20) + Kibana 7.17, 총 7개 서비스를 Docker Compose로 구성했습니다. 5개 Named Volume(mysql_data, redis_data, es_data, gradle_cache, frontend_node_modules)으로 데이터를 영속화하고, `cms-network` 브릿지 네트워크로 서비스 간 통신을 격리합니다.

---

### G-02. 커스텀 Elasticsearch Docker 이미지 (Nori 플러그인)

공식 ES 이미지에 Nori 한국어 분석기가 포함되어 있지 않아, `docker/elasticsearch/Dockerfile`에서 `FROM elasticsearch:7.17.25` 기반으로 `RUN bin/elasticsearch-plugin install --batch analysis-nori`를 실행하는 커스텀 이미지를 빌드했습니다. 운영 서버에서는 `elasticsearch-plugin install analysis-nori` 수동 설치로 동일 환경을 재현합니다.

---

### G-03. Nginx 리버스 프록시 설계 (7개 라우팅 규칙)

`cms.conf`(138 lines)에 7개 location 블록을 설계했습니다: (1) `/contents/cms/` → 업로드 파일 직접 서빙(1년 캐시), (2) `/public/` → 정적 자원, (3) `/cms/json/` → JSON 데이터, (4) `/swagger-ui/` → 백엔드(IP 제한), (5) `/back-api/` → 백엔드 프록시, (6) `/static/` → 백엔드 정적, (7) `/` → Nuxt 프론트엔드. keepalive 32 커넥션, 50MB 업로드 제한, WebSocket 업그레이드(HMR 지원), 폰트 CORS 헤더를 설정했습니다.

---

### G-04. Jenkins CI/CD 파이프라인 (4단계 + 수동 승인)

`Jenkinsfile`(83 lines)에 Checkout → Build → Archive → Deploy 4단계 파이프라인을 구성했습니다. Deploy 단계에 수동 승인(`input "배포를 진행하시겠습니까?"`)을 추가하여 실수 배포를 방지합니다. Gitea에서 소스를 체크아웃하고, `./gradlew clean build -x test`로 빌드 후, SCP로 JAR + deploy.sh를 운영 서버에 전송하고 SSH로 실행합니다.

---

### G-05. 운영 배포 스크립트 (Zero-Downtime 목표)

`deploy.sh`(23 lines)가 운영 서버에서 기존 Java 프로세스를 `pkill -f 'java -jar'`로 종료하고, `nohup java -jar -Dspring.profiles.active=prod`로 새 버전을 백그라운드 실행합니다. 날짜별 로그 파일(`api_YYYYMMDD.log`)로 분리하여 로그 관리를 용이하게 했습니다.

---

### G-06. Git 브랜치 전략 및 Webhook 설정

`main`(운영) + `feature/*`(개발) 전략을 수립했습니다. Gitea Webhook Branch Filter를 `main`으로 설정하여 feature push 시 Jenkins가 트리거되지 않습니다. `--ff-only` 머지 정책으로 main의 선형 히스토리를 유지하고, main 직접 커밋을 금지합니다.

- **Trouble Shooting**: 초기 Webhook 설정에서 Branch Filter가 비어 있어 feature push에도 Jenkins가 트리거되었습니다. Branch Filter를 `main`으로 설정하여 해결했습니다.

---

### G-07. WSL2 I/O 최적화 (빌드 속도 5~10배 개선)

Windows bind mount의 NTFS↔Linux 파일시스템 변환 오버헤드로 빌드 속도가 극도로 저하되는 문제를 발견했습니다. 프로젝트를 WSL2 네이티브 파일시스템(`/home/` 하위)으로 이전하고, Docker Compose에서 WSL2 경로를 직접 마운트하여 빌드 속도를 5~10배 개선했습니다.

---

### G-08. 환경 전환 자동화 스크립트

`switch-env.sh`가 `local`/`remote` 인자에 따라 `.env.local` 또는 `.env.remote`를 `.env`로 복사합니다. local 모드에서 `.env.local`이 없으면 기본값으로 자동 생성합니다. 전환 후 `docker compose down && docker compose up -d` 안내를 출력합니다.

---

## H. AOP & 횡단 관심사 (Cross-Cutting)

### H-01. @ExecutionTime 커스텀 어노테이션 기반 성능 측정

`@ExecutionTime(description, level, unit)` 어노테이션과 `ExecutionTimeAspect`를 구현하여, 메서드 실행 시간을 지정 단위(NANO/MICRO/MILLI/SECONDS)와 로그 레벨(DEBUG/INFO/WARN/ERROR)로 측정·기록합니다. 예외 발생 시에도 실행 시간을 기록하여 성능 병목을 파악합니다.

---

### H-02. 비동기 로그인 감사 로깅 (LoginLogAspect)

`LoginLogAspect`가 로그인 성공 이벤트를 감지하여, IP 주소·타임스탬프·사용자 정보를 `LoginLogService`를 통해 비동기(`@Async`)로 기록합니다. 로그인 처리 응답 시간에 영향을 주지 않으면서 감사 추적을 확보합니다.

---

### H-03. 방문자 추적 인터셉터 및 스케줄러

`VisitorInterceptor`가 `/back-api/auth/me` 경로에서 방문자 정보를 수집하고, `VisitorServiceImpl`이 일별 방문 통계를 관리합니다. `VisitorMigrationService`가 스케줄링(@EnableScheduling)으로 방문 데이터를 주기적으로 집계·마이그레이션합니다.

---

## I. 메뉴 & 콘텐츠 관리 (Menu & Content)

### I-01. 메뉴 트리 JSON Export 및 버전 관리

`MenuSyncProcessor`가 메뉴 CRUD 시 계층 트리를 JSON 파일(`/data/egovframe-cms/front/shared/json/`)로 내보내어, 프론트엔드가 API 호출 없이 정적 JSON에서 메뉴를 로드합니다. `MenuSyncLock`으로 동시 Export를 방지하고, `JsonVersionService`가 버전을 관리하여 캐시 무효화 시점을 제어합니다.

---

### I-02. 드래그앤드롭 메뉴 트리 편집기

프론트엔드 `useMenuDragDrop()` composable이 메뉴 트리의 드래그앤드롭 재배치를 구현합니다. `useMenuTreeOperations()`가 CRUD 작업을, `useMenuVersionManager()`가 메뉴 버전 이력을 관리하여, 변경 전 상태로 롤백할 수 있습니다.

---

### I-03. 콘텐츠 파일 첨부 및 이력 관리

`ContentFileServiceImpl`이 파일 업로드·다운로드·삭제를 처리하고, `useContentFiles()` composable이 프론트엔드 파일 관리를 담당합니다. `useContentHistory()`가 콘텐츠 수정 이력을 관리하여 이전 버전 조회 및 비교가 가능합니다. `useContentPreview()`로 발행 전 미리보기를 제공합니다.

---

## J. LLM 기반 개발 프로세스 (AI-Assisted Dev)

### J-01. BMad 에이전트 프레임워크 기반 설계 산출물 표준화

BMad 에이전트 프레임워크와 Claude Code CLI를 활용하여 Product Brief → PRD(46 FR + 35 NFR) → Architecture → Epics(6개) → Stories(21개) → Implementation Artifacts(18개)의 산출물 체인을 수립했습니다. 모든 산출물은 Markdown 기반으로 Git 버전 관리되며, 요구사항 추적 매트릭스로 100% 커버리지를 검증합니다.

---

### J-02. LLM 산출물 검증 프로세스 구축

LLM이 생성한 설계·코드 초안에 대해 도메인 제약 조건 점검, 인터페이스 정합성 검증, 비기능 요구사항(성능·장애·권한) 누락 확인을 수행하는 `implementation-readiness-report.md` 검증 프로세스를 구축했습니다. 46 FR 전체 매핑, Epic 품질, UX 정합성을 체크리스트로 검증하여 READY FOR IMPLEMENTATION 판정을 받은 후에만 구현에 착수합니다.

---

### J-03. 에이전트/페르소나/스킬 기반 규칙 체계

Claude Code의 CLAUDE.md, 에이전트 규칙, 페르소나 정의, 스킬 설정을 통해 코드 리뷰, 문서 생성, 아키텍처 검증 등 역할별 AI 워크플로를 구축했습니다. BMad 스킬(`bmad-workflow`, `bmad-review-adversarial-general`, `bmad-editorial-review-prose` 등)을 활용하여 산출물 품질을 자동 검증합니다.

---

## K. 문서화 & 팀 기여 (Documentation)

### K-01. 아키텍처 설계 문서 체계 구축

`architecture.md`에 데이터 전략(하이브리드 인덱싱, Alias Swap), 보안 전략(ES API Key + TLS, 이중 권한 필터링), API 설계(REST + Circuit Breaker), 프론트엔드 전략(CSR 검색, Pinia), 인프라 전략(단일 → 3노드 확장), 네이밍 규칙(DB: cms_search_ 접두사, API: /back-api/search, 패키지: kr.co.itid.cms.search)을 체계적으로 문서화했습니다.

---

### K-02. Elasticsearch 검색 통합 문서

`ES_SEARCH_INTEGRATION.md`(19KB)에 아키텍처 개요, 파일 참조 가이드, ES 인덱스 설계(Nori 분석기), 콘텐츠 매핑(PAGE/POST/MENU), 검색 API 스펙, 데이터 일관성 전략, 권한 필터링 접근법을 기록했습니다.

---

### K-03. 환경 설정 가이드

`ENVIRONMENT_SETUP.md`에 프로파일 기반 설정, .env 파일 관리, Docker Compose 셋업, 환경 전환 스크립트 사용법을 기록하여 신규 팀원 온보딩 시간을 단축했습니다.

---

### K-04. 보안 아키텍처 문서

`SECURITY.md`(10KB)에 CMS 보안 경계, 검색 시스템 인증 통합, Elasticsearch 보안(API Key, TLS), 권한 모델을 기록하여 보안 감사 시 참조 문서로 활용합니다.

---

### K-05. 미들웨어 파이프라인 README

프론트엔드 `middleware/README.md`에 5계층 미들웨어의 실행 순서, 각 미들웨어의 기능·특징·SSR/CSR 대응 방식, 전체 설계 철학(관심사 분리, redirect loop 방지, 멀티사이트 최적화)을 문서화하여 고급 Nuxt SSR/CSR 구조의 유지보수 가이드를 제공합니다.

---

> **사용법**: 지원하는 회사의 JD에 맞춰 A~K 카테고리에서 관련 항목을 선별하여 조합하세요.
> - **백엔드 중심 포지션**: A + B + C + D + H 위주
> - **풀스택 포지션**: A + B + E + F 위주
> - **DevOps 포지션**: A-05 + G + H-03 위주
> - **검색/데이터 포지션**: D 전체 + C + A-06 위주
> - **AI/LLM 활용 포지션**: J 전체 + K 위주
