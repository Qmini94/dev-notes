## Q1. 문제 상황을 구체적으로 설명해 주세요.

Gradle 빌드에서 QueryDSL의 Q클래스 생성, MapStruct의 매핑 코드 생성, Lombok의 보일러플레이트 생성 이 세 가지 어노테이션 프로세서가 같은 컴파일 단계에서 동시에 실행되면서 충돌이 발생했습니다. 구체적으로는 MapStruct가 매핑 코드를 생성하려고 할 때 아직 Q클래스가 만들어지지 않은 상태여서 참조를 못 하거나, 반대로 Q클래스 생성 시점에 Lombok이 만든 getter/setter를 인식하지 못하는 식이었습니다. 로컬에서는 되다가 안 되다가 하고, CI 환경에서는 더 빈번하게 실패해서 빌드 안정성이 심각하게 떨어졌습니다.

---

## Q2. 왜 세 프로세서가 같은 단계에서 경합하면 문제가 생기나요?

Java 컴파일러의 어노테이션 프로세싱은 라운드 기반으로 동작합니다. 같은 라운드에 여러 프로세서가 등록되어 있으면 실행 순서가 보장되지 않습니다. QueryDSL은 엔티티 클래스를 읽어서 Q클래스 소스 파일을 생성하고, MapStruct는 인터페이스를 읽어서 매핑 구현체를 생성하는데, MapStruct 매퍼가 Q클래스를 참조하는 경우 Q클래스가 아직 생성되지 않은 상태에서 MapStruct가 먼저 실행될 수 있습니다. Lombok도 마찬가지로 getter나 builder를 생성하기 전에 다른 프로세서가 해당 메서드를 참조하려고 하면 컴파일 에러가 납니다. 순서가 보장되지 않으니 실행할 때마다 결과가 달라지는 비결정적 실패가 발생한 것입니다.

---

## Q3. 해결 방법을 구체적으로 설명해 주세요.

핵심은 프로세서들의 실행 단계를 물리적으로 분리한 것입니다. QueryDSL Q클래스 생성을 별도의 JavaCompile Task로 분리하고, 이 Task에는 proc:only 옵션을 줘서 어노테이션 프로세싱만 수행하고 실제 컴파일은 하지 않도록 했습니다. 그다음 메인 compileJava Task가 이 Q클래스 생성 Task에 의존하도록 순서를 명시했습니다. 이렇게 하면 Q클래스가 먼저 확실히 생성된 상태에서 메인 컴파일이 시작됩니다. MapStruct와 Lombok은 메인 컴파일 단계에서만 동작하도록 조건을 분기해서, Q클래스 생성 Task에서는 이 두 프로세서가 실행되지 않게 했습니다.

---

## Q4. proc:only 옵션은 정확히 어떤 역할을 하나요?

Java 컴파일러에 proc:only 옵션을 주면 어노테이션 프로세싱만 수행하고 실제 바이트코드 컴파일은 건너뜁니다. 소스 파일을 생성하는 것까지만 하고 멈추는 거라서, Q클래스 소스 파일만 만들어놓고 컴파일은 나중에 메인 Task에서 하겠다는 의미입니다. 이 옵션 덕분에 Q클래스 생성을 독립된 단계로 깔끔하게 분리할 수 있었습니다. 메인 compileJava에서는 이미 생성된 Q클래스 소스를 포함해서 전체를 한 번에 컴파일하기 때문에, Q클래스가 없어서 참조 실패하는 문제가 원천적으로 사라집니다.

---

## Q5. 디버깅용 classpath 출력 Task는 왜 추가했나요?

빌드 실패 원인을 추적할 때 가장 어려웠던 게 classpath 문제였습니다. 어떤 라이브러리가 어떤 버전으로 잡혀 있는지, Q클래스 생성 경로가 제대로 포함되어 있는지, 프로세서 JAR가 올바르게 등록되어 있는지를 확인하려면 classpath를 직접 봐야 하는데, Gradle이 기본으로 보여주지는 않습니다. 그래서 빌드 시 classpath와 프로세서 목록을 출력하는 Task를 따로 만들어뒀습니다. 빌드 문제가 다시 발생하면 이 Task를 실행해서 현재 classpath 상태를 바로 확인할 수 있어서, 원인 추적 시간이 크게 줄었습니다.

---

## Q6. 로컬에서는 되는데 CI에서 실패하는 현상의 원인은 무엇이었나요?

로컬 빌드에서는 이전 빌드의 캐시가 남아 있어서 Q클래스가 이미 생성된 상태인 경우가 많았습니다. 그래서 프로세서 순서가 꼬여도 기존에 생성된 Q클래스를 참조할 수 있어 빌드가 통과하는 것처럼 보였습니다. 반면 CI 환경에서는 매번 클린 빌드를 수행하기 때문에 캐시가 없는 상태에서 시작하고, 프로세서 경합 문제가 그대로 드러났습니다. 이게 디버깅을 더 어렵게 만들었는데, 로컬에서 재현이 안 되니까 원인 파악에 시간이 걸렸습니다. Task 분리 후에는 캐시 유무와 관계없이 항상 동일한 순서로 실행되기 때문에 환경에 따른 차이가 사라졌습니다.

---

## Q7. 이 경험에서 어떤 교훈을 얻었나요?

두 가지 교훈이 있었습니다. 첫째, 어노테이션 프로세서를 여러 개 사용할 때는 실행 순서와 의존 관계를 반드시 명시적으로 관리해야 한다는 점입니다. 프레임워크가 알아서 해주겠지 하고 넘기면 비결정적 실패가 나중에 터집니다. 둘째, CI 환경과 로컬 환경의 차이를 항상 의식해야 한다는 점입니다. 로컬에서 통과한다고 안심할 게 아니라, 클린 빌드 상태에서의 동작을 기준으로 검증해야 합니다. 이후로는 빌드 설정을 변경할 때 반드시 CI에서 클린 빌드로 검증하는 습관을 갖게 되었습니다.