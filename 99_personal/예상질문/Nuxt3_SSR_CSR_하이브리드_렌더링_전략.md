## Q1. SSR/CSR 하이브리드 전략이란 구체적으로 어떤 방식인가요?

모든 페이지가 SSR과 CSR을 모두 거치는 구조입니다. 사용자가 처음 접근하면 서버에서 HTML을 렌더링해서 내려주고, 이후 브라우저에서 Hydration을 통해 Vue 앱으로 전환됩니다. 페이지별로 SSR이냐 CSR이냐를 나눈 게 아니라, 모든 페이지가 동일하게 SSR에서 CSR로 이어지는 2단계를 거칩니다. 대신 미들웨어 내부에서 서버 환경인지 클라이언트 환경인지를 분기해서 각 단계의 동작을 다르게 처리하는 방식을 채택했습니다. 이를 통해 SEO와 초기 로딩 속도를 확보하면서도, Hydration 이후에는 SPA처럼 빠른 인터랙션을 제공할 수 있었습니다.

---

## Q2. Hydration Mismatch란 무엇이고, 이 프로젝트에서 왜 문제가 되었나요?

Hydration Mismatch는 서버에서 만든 HTML과 클라이언트에서 Vue가 다시 구성한 DOM이 일치하지 않을 때 발생하는 오류입니다. 이 프로젝트에서는 모든 페이지가 SSR에서 CSR로 이어지기 때문에, 미들웨어가 서버에서 한 번, 클라이언트에서 한 번 총 두 번 실행됩니다. 이때 IP 접근 제어, 인증, 메뉴 매칭, 권한 검사 같은 로직이 서버와 클라이언트에서 서로 다른 결과를 만들면 Mismatch가 발생합니다. 예를 들어 서버에서는 리다이렉트했는데 클라이언트에서는 그대로 통과한다거나, 메뉴 경로 정규화 결과가 달라지는 경우가 대표적이었습니다.

---

## Q3. 미들웨어 파이프라인을 5단계로 분리한 구조와 그 이유를 설명해 주세요.

사이트 초기화 및 IP 접근 제어, 인증 및 사이트 개폐 제어, 메뉴 경로 처리, 렌더 데이터 및 권한 검사, 레이아웃 선택 이렇게 5단계로 구성했습니다. 각 단계가 이전 단계의 결과에 의존하기 때문에 순서가 중요합니다. IP 차단이 먼저 이루어져야 인증 미들웨어가 불필요하게 실행되지 않고, 메뉴 트리가 로딩되어야 권한 검사를 할 수 있고, 권한까지 확정되어야 올바른 레이아웃을 선택할 수 있습니다. 이렇게 책임을 나누면 각 미들웨어가 자기 역할만 담당하니까 디버깅이 쉬워지고, SSR과 CSR 분기 처리도 각 단계 안에서 독립적으로 관리할 수 있었습니다.

---

## Q4. SSR과 CSR에서 미들웨어가 두 번 실행되는 문제를 어떻게 해결했나요?

핵심은 SSR에서 리다이렉트가 발생했을 때, CSR에서 같은 리다이렉트가 중복 실행되면서 무한 루프에 빠지는 걸 막는 것이었습니다. 두 가지 방법을 병행했습니다. 첫째, useState를 활용해서 SSR에서 리다이렉트를 한 번 수행한 뒤 플래그를 설정하고, 같은 요청 안에서 재실행되면 바로 리턴하도록 했습니다. 둘째, URL 쿼리에 redirected 파라미터를 추가해서, 리다이렉트된 페이지에서 다시 미들웨어가 실행되더라도 중복 리다이렉트를 방지했습니다. 그리고 SSR에서는 302 상태 코드로 서버 리다이렉트를 하고, CSR에서는 replace 옵션으로 클라이언트 이동을 처리해서 각 환경에 맞게 분기했습니다.

---

## Q5. IP 접근 제어에서 SSR과 CSR의 동작이 다른 이유와 해결 방법을 설명해 주세요.

근본적인 문제는 클라이언트 환경에서는 사용자의 실제 IP를 알 수 없다는 점입니다. SSR에서는 X-Forwarded-For 헤더에서 실제 IP를 추출해서 allow와 deny 정책을 평가할 수 있지만, CSR에서는 그 정보에 접근할 수가 없습니다. 그래서 SSR에서 IP 차단이 결정되면 ipBlock이라는 쿠키를 응답 헤더에 설정하고, CSR에서는 그 쿠키가 있는지만 확인해서 차단 상태를 유지하는 방식을 적용했습니다. 이걸 통해 SSR에서 차단된 사용자가 CSR Hydration 단계에서 뒤의 인증이나 메뉴 미들웨어까지 타버리는 걸 완전히 방지할 수 있었습니다.

---

## Q6. 메뉴 경로 처리 미들웨어에서 경로 정규화와 폴더 메뉴 리다이렉트는 어떻게 동작하나요?

경로 정규화는 URL에 슬래시가 중복되거나 끝에 불필요한 슬래시가 붙는 걸 정리하는 처리입니다. SSR에서는 301 리다이렉트로 정규화된 경로를 반환해서, 크롤러와 브라우저 모두에게 올바른 URL을 전달합니다. 이 정규화가 SSR에서 먼저 이루어져야 CSR Hydration 시 경로 불일치로 인한 Mismatch를 막을 수 있습니다. 폴더 메뉴의 경우에는 사용자가 폴더 경로에 접근하면 그 폴더의 첫 번째 자식 메뉴로 자동 리다이렉트합니다. 이때도 useState 플래그로 SSR에서 1회만 리다이렉트하도록 보호해서 302 루프를 방지했습니다.

---

## Q7. 권한 검사 미들웨어에서 mode별 권한 분기는 어떤 의미인가요?

렌더 데이터에는 access, view, write, modify 네 가지 권한이 포함됩니다. URL 쿼리의 mode 값에 따라 검사 대상 권한을 다르게 적용합니다. 예를 들어 게시글 목록에서는 access 권한만 확인하지만, 글쓰기 모드로 진입하면 write 권한을 검사합니다. 권한이 없으면 게스트는 로그인 페이지로, 로그인된 사용자는 사이트 메인으로 리다이렉트하는데, SSR에서는 서버 리다이렉트로, CSR에서는 알림 메시지와 함께 클라이언트 이동으로 처리합니다. 이를 통해 하나의 페이지에서 조회와 수정 같은 여러 동작에 대한 권한을 유연하게 제어할 수 있었습니다.

---

## Q8. 레이아웃 선택 미들웨어가 다른 미들웨어와 독립적으로 동작하는 이유는 무엇인가요?

레이아웃 선택은 URL 경로와 사이트 설정만으로 결정할 수 있기 때문입니다. 빌드 타임에 존재하는 레이아웃 파일 목록을 미리 수집해두고, 사이트명을 slug로 변환해서 메인 레이아웃인지 서브 레이아웃인지를 매칭합니다. 해당 파일이 없으면 default 계열로 안전하게 폴백합니다. 이 미들웨어는 리다이렉트를 수행하지 않고 레이아웃 메타 정보만 설정하기 때문에 SSR과 CSR에서 완전히 동일한 결과가 나옵니다. 리다이렉트가 없으니 Mismatch 위험도 없고, 앞선 미들웨어들의 상태에 의존하지 않아서 독립적으로 동작할 수 있었습니다.

---

## Q9. Static JSON과 Spring Cache의 2단계 캐싱 구조를 설명해 주세요.

1단계는 프론트엔드 쪽의 Static JSON 캐싱입니다. 메뉴 구조나 사이트 설정처럼 변경 빈도가 낮은 데이터를 JSON 파일로 미리 만들어두고, SSR 시 API 호출 없이 그 파일을 직접 읽어서 렌더링합니다. 2단계는 백엔드 쪽의 Spring Cache인데, API 호출이 발생하더라도 자주 조회되는 데이터는 메모리 캐시에서 바로 응답합니다. 이렇게 양쪽에 캐싱 레이어를 두면 API 호출 자체를 줄이면서, 호출이 발생해도 응답 시간을 최소화할 수 있었습니다. 특히 Static JSON 덕분에 백엔드 서버에 장애가 생겨도 기본적인 페이지 구조와 메뉴가 정상적으로 렌더링되어 가용성을 확보할 수 있었습니다.

---

## Q10. 이 구조에서 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재 미들웨어 간 상태 전달이 Pinia 스토어와 useState에 분산되어 있는데, 미들웨어 실행 컨텍스트를 통합적으로 관리하는 구조를 도입하면 디버깅이 더 쉬워질 것입니다. 둘째, Static JSON 갱신이 데이터 변경 시점에 동기적으로 이루어지는데, 변경 빈도가 높아지면 이벤트 기반 비동기 갱신으로 전환해서 백엔드 부하를 줄일 수 있을 것입니다. 이런 개선을 통해 미들웨어 파이프라인의 유지보수성과 캐싱 구조의 안정성을 한 단계 더 높일 수 있을 것입니다.