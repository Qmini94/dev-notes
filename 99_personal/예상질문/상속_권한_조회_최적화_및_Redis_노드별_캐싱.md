## Q1. 기존 레거시 권한 조회 구조는 어떤 문제가 있었나요?

기존에는 메뉴가 트리 구조로 되어 있고, 상위 메뉴의 권한이 하위 메뉴로 상속되는 구조였습니다. 그런데 특정 메뉴의 최종 권한을 알려면 해당 메뉴부터 루트까지 부모를 하나씩 타고 올라가면서 권한을 조회해야 했습니다. 이게 재귀 쿼리나 반복 쿼리로 구현되어 있어서, 트리 깊이가 깊어지면 쿼리 수가 비례해서 늘어났습니다. 메뉴가 3단계면 3번, 5단계면 5번 쿼리가 나가는 식이었고, 여기에 캐싱도 전체 권한을 하나의 키에 통째로 담는 구조여서 일부 메뉴 권한이 변경되면 전체 캐시를 무효화해야 하는 비효율이 있었습니다.

---

## Q2. pathId를 도입한 구조를 구체적으로 설명해 주세요.

메뉴 테이블에 pathId라는 필드를 추가해서, 각 메뉴의 루트부터 자기 자신까지의 전체 경로를 dot으로 연결한 문자열로 기록합니다. 예를 들어 루트가 1이고 그 하위가 3이고 그 하위가 8이면 pathId가 "1.3.8"이 됩니다. 조상 조회가 필요하면 이 문자열을 dot 기준으로 분할하면 한 번에 모든 조상 ID를 알 수 있고, 하위 노드 조회가 필요하면 "1.3.8"로 시작하는 pathId를 LIKE 접두사 쿼리로 한 번에 가져올 수 있습니다. 기존에 트리 깊이만큼 반복하던 쿼리가 문자열 분할 한 번이나 LIKE 쿼리 한 번으로 줄어든 것입니다.

---

## Q3. pathId 방식의 트레이드오프는 무엇인가요?

가장 큰 트레이드오프는 메뉴 구조가 변경될 때 pathId를 갱신해야 한다는 점입니다. 메뉴의 부모가 바뀌거나 이동되면 해당 메뉴뿐 아니라 모든 하위 메뉴의 pathId도 함께 업데이트해야 합니다. 다만 CMS 환경에서 메뉴 구조 변경은 관리자가 간헐적으로 수행하는 작업이고, 조회는 모든 사용자 요청마다 발생하기 때문에 읽기 빈도가 쓰기 빈도에 비해 압도적으로 높습니다. 조회 성능을 극적으로 개선하는 대신 드물게 발생하는 구조 변경 시 약간의 비용을 감수하는 것이 이 환경에서는 합리적인 선택이었습니다.

---

## Q4. Redis 캐싱을 노드별로 분리한 이유는 무엇인가요?

기존에는 사용자의 전체 권한 정보를 하나의 Redis 키에 통째로 담고 있었습니다. 이 구조에서는 메뉴 하나의 권한만 변경되어도 그 사용자의 전체 권한 캐시를 무효화하고 다시 만들어야 합니다. 메뉴가 수십 개이고 사용자가 수백 명이면 작은 변경 하나가 대량의 캐시 재생성으로 이어집니다. 노드별로 분리하면 특정 메뉴의 권한이 변경되었을 때 해당 노드의 캐시만 무효화하면 되기 때문에, 캐시 무효화 범위가 최소화되고 나머지 메뉴의 캐시는 그대로 유지됩니다.

---

## Q5. 노드별 캐싱의 키 구조는 어떻게 설계했나요?

메뉴 ID와 사용자 또는 역할 식별자를 조합해서 키를 구성합니다. 예를 들어 특정 역할이 특정 메뉴에 대해 가진 권한이라면 그 조합이 하나의 키가 됩니다. 권한 조회 요청이 오면 먼저 해당 키로 Redis를 조회하고, 캐시가 있으면 바로 반환합니다. 없으면 pathId를 분할해서 조상 목록을 구한 뒤 DB에서 권한을 조회하고, 상속 규칙을 적용해서 최종 권한을 계산한 다음 그 결과를 Redis에 캐싱합니다. 이렇게 하면 같은 메뉴에 대한 권한 조회가 반복될 때 DB를 거치지 않고 Redis에서 즉시 응답할 수 있습니다.

---

## Q6. 권한 상속 규칙은 어떻게 적용되나요?

조상 목록을 루트부터 현재 메뉴까지 순서대로 확인하면서, 각 노드에 명시적으로 설정된 권한이 있으면 그걸 적용하고 없으면 부모의 권한을 그대로 이어받는 방식입니다. 예를 들어 루트에서 읽기 권한만 부여했는데 중간 메뉴에서 쓰기 권한을 추가로 설정했다면, 그 하위 메뉴들은 읽기와 쓰기 모두를 상속받습니다. pathId 덕분에 조상 목록을 한 번에 알 수 있으니까, 이 상속 계산을 단일 조회 결과만으로 수행할 수 있습니다. 기존에는 재귀적으로 부모를 타고 올라가면서 매번 쿼리를 날려야 했던 것과 비교하면 훨씬 효율적입니다.

---

## Q7. 쿼리 수 75% 감소와 응답 속도 10배 개선이라는 수치는 어떻게 측정했나요?

기존 구조에서 평균적인 메뉴 깊이와 요청 패턴을 기준으로 권한 조회 시 발생하는 쿼리 수를 측정하고, pathId 도입 후 동일한 시나리오에서의 쿼리 수를 비교했습니다. 예를 들어 4단계 깊이의 메뉴에서 기존에는 4번의 쿼리가 필요했는데 pathId로 1번이면 되니까 75% 감소입니다. 응답 속도는 캐시 미적중 상태에서 DB 조회까지 포함한 응답 시간과, 노드별 캐싱 적용 후 캐시 적중 상태에서의 응답 시간을 비교한 것입니다. 캐시 미적중 시 200ms 이상 걸리던 것이 캐시 적중 시 20ms 이하로 줄어들어 10배 이상 개선되었습니다.

---

## Q8. 캐시 무효화는 구체적으로 어떤 시점에 발생하나요?

크게 두 가지 시점입니다. 첫째, 관리자가 특정 메뉴의 권한을 변경할 때 해당 노드와 그 하위 노드들의 캐시를 무효화합니다. 하위 노드 범위는 pathId의 LIKE 접두사 쿼리로 빠르게 파악할 수 있습니다. 둘째, 사용자의 역할이 변경되거나 강제 로그아웃이 발생할 때 해당 사용자와 관련된 권한 캐시를 무효화합니다. 노드별로 캐시가 분리되어 있기 때문에 변경이 발생한 범위만 정확하게 무효화할 수 있고, 나머지 캐시는 영향 없이 유지됩니다. 이 점이 전체 권한을 하나의 키로 관리하던 기존 구조와의 가장 큰 차이입니다.

---

## Q9. 이 구조에서 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재 권한 변경 시 하위 노드 캐시 무효화가 동기적으로 이루어지는데, 하위 노드가 많아지면 무효화 자체에 시간이 걸릴 수 있습니다. 이벤트 기반 비동기 무효화로 전환하면 관리자 응답 시간을 줄일 수 있을 것입니다. 둘째, pathId 갱신 시 하위 메뉴 전체를 업데이트하는 로직에 트랜잭션 안전성을 더 강화하고 싶습니다. 현재도 트랜잭션 내에서 처리하고 있지만, 대규모 트리 이동 시나리오에서의 원자성 보장을 더 꼼꼼하게 검증할 필요가 있다고 생각합니다. 이런 개선을 통해 권한 시스템의 안정성과 운영 효율을 한 단계 더 높일 수 있을 것입니다.