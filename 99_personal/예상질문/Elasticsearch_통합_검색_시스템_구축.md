## Q1. Elasticsearch를 도입하게 된 배경은 무엇인가요?

동적 게시판 구조 특성상 게시판 유형별로 테이블이 분리되어 있어서, 일반 SQL로는 여러 게시판에 걸친 통합 검색이 어려웠습니다. UNION ALL로 묶는 방법도 있지만 테이블이 수십 개이고 계속 늘어나는 환경에서는 현실적이지 않았습니다. 거기에 한국어 형태소 분석 기반의 풀텍스트 검색이 필요했는데, RDB의 LIKE 검색으로는 조사나 어미 변화를 처리할 수 없었습니다. 그래서 분산된 테이블의 데이터를 하나의 Elasticsearch 인덱스에 통합 색인하고, Nori 형태소 분석기로 한국어 검색 품질을 확보하는 구조를 설계했습니다.

---

## Q2. Nori 형태소 분석기를 선택한 이유와 설정 방식을 설명해 주세요.

한국어는 조사, 어미 변화가 다양해서 단순 키워드 매칭으로는 검색 품질이 낮습니다. 예를 들어 사용자가 "개발"을 검색했을 때 "개발자", "개발하는", "개발을" 같은 변형도 매칭되어야 합니다. Nori는 Elasticsearch에서 공식 지원하는 한국어 형태소 분석기로, 별도 외부 의존성 없이 플러그인 설치만으로 사용할 수 있습니다. 인덱스 매핑에서 분석기를 Nori로 지정하면 색인 시점에 텍스트를 형태소 단위로 분리해서 저장하고, 검색 시에도 쿼리를 같은 방식으로 분석해서 매칭합니다. 복합명사 처리를 위한 decompound 옵션도 활용했습니다.

---

## Q3. 다차원 색인이란 구체적으로 어떤 의미인가요?

단순히 게시글 제목과 본문만 색인하는 게 아니라, 검색 결과 필터링에 필요한 메타 정보까지 함께 색인한다는 의미입니다. 구체적으로 게시글의 공개 상태, 어떤 사이트에 속하는지, 어떤 메뉴에 속하는지, 그 메뉴의 접근 권한 수준까지 문서에 포함시켜서 색인합니다. 이렇게 하면 검색 쿼리를 보낼 때 텍스트 매칭과 권한 필터링을 하나의 쿼리로 처리할 수 있습니다. 먼저 텍스트로 검색한 다음 애플리케이션에서 권한 필터링을 하는 것보다 훨씬 효율적이고, Elasticsearch가 필터 캐싱까지 해주기 때문에 반복 검색 시 성능이 더 좋아집니다.

---

## Q4. 검색 시 권한 필터링은 구체적으로 어떻게 동작하나요?

사용자가 검색 요청을 보내면, 백엔드에서 해당 사용자의 권한 정보를 먼저 확인합니다. 그다음 Elasticsearch 쿼리를 구성할 때 bool 쿼리의 must에 텍스트 매칭 조건을, filter에 공개 상태, 사이트 식별자, 사용자가 접근 가능한 메뉴 목록을 넣습니다. filter 절은 스코어링에 영향을 주지 않으면서 결과를 걸러내고, Elasticsearch가 내부적으로 캐싱하기 때문에 성능에도 유리합니다. 이렇게 하면 사용자는 자기가 볼 수 있는 게시글만 검색 결과에 나오게 되고, 권한 없는 콘텐츠가 노출되는 문제를 원천적으로 방지할 수 있습니다.

---

## Q5. Transactional Outbox 패턴으로 색인 동기화를 보장한 방식을 설명해 주세요.

게시글이 생성되거나 수정될 때 DB 트랜잭션과 Elasticsearch 색인을 동기화해야 하는데, 이 둘은 서로 다른 시스템이기 때문에 분산 트랜잭션 문제가 생깁니다. DB에는 저장됐는데 색인이 실패하거나, 그 반대 상황이 발생할 수 있습니다. Transactional Outbox 패턴은 게시글 저장과 함께 같은 DB 트랜잭션 안에서 색인 이벤트를 Outbox 테이블에 기록합니다. 별도 프로세스가 이 Outbox 테이블을 폴링해서 미처리 이벤트를 읽고 Elasticsearch에 색인한 뒤 처리 완료로 표시합니다. DB 트랜잭션이 롤백되면 Outbox 레코드도 함께 롤백되니까 일관성이 보장됩니다.

---

## Q6. Outbox 폴링 방식 대신 Redis Streams 같은 이벤트 기반으로 처리하지 않은 이유가 있나요?

Redis Streams를 쓰면 DB 트랜잭션과 이벤트 발행 사이에 일관성을 보장하기가 어렵습니다. DB에는 커밋됐는데 Redis 발행이 실패하거나, 반대로 Redis에는 발행됐는데 DB가 롤백되는 상황이 생길 수 있습니다. Outbox 패턴은 이벤트 자체를 같은 DB 트랜잭션에 넣기 때문에 이 문제가 원천적으로 없습니다. 물론 폴링 방식이라 약간의 지연은 있지만, 검색 색인은 실시간이 아니라 준실시간 수준이면 충분하기 때문에 일관성을 우선한 선택이었습니다. 감사 로깅처럼 유실되어도 폴백이 가능한 경우와는 요구사항이 다릅니다.

---

## Q7. Read/Write Alias Swap 전략은 어떻게 동작하나요?

재색인이 필요할 때 기존 인덱스를 직접 수정하는 게 아니라, 새 인덱스를 별도로 만들어서 전체 데이터를 색인한 뒤 Alias를 전환하는 방식입니다. 평소에는 Read Alias가 현재 운영 인덱스를 가리키고, Write Alias도 같은 인덱스를 가리킵니다. 재색인 시에는 새 인덱스를 생성하고 Write Alias를 새 인덱스로 전환해서 신규 데이터가 새 인덱스에 쌓이게 합니다. 기존 데이터도 새 인덱스로 마이그레이션이 완료되면 Read Alias를 새 인덱스로 전환합니다. 검색 서비스는 항상 Read Alias를 통해 쿼리하기 때문에 전환 순간에도 중단이 없습니다.

---

## Q8. 재색인이 필요한 상황은 언제인가요?

크게 세 가지 경우입니다. 첫째, 매핑 변경이 필요할 때입니다. 예를 들어 검색 대상 필드를 추가하거나 분석기 설정을 변경하면 기존 인덱스의 매핑은 수정이 안 되기 때문에 새 인덱스가 필요합니다. 둘째, Outbox 기반 증분 색인에서 누락이 발생했거나 데이터 정합성을 맞추기 위해 전체 재색인을 수행하는 경우입니다. 셋째, Nori 분석기 설정을 튜닝하거나 동의어 사전을 업데이트할 때입니다. 이런 상황에서 Alias Swap 덕분에 재색인 도중에도 사용자는 기존 인덱스로 정상 검색이 가능합니다.

---

## Q9. k6 부하 테스트 결과를 설명해 주세요.

약 80만 건 규모의 인덱스를 대상으로 k6으로 30에서 50 RPS 수준의 검색 부하를 걸어서 테스트했습니다. 권한 필터를 포함한 통합 검색 기준으로 평균 응답 시간이 40ms, p95가 85ms 수준이었습니다. 검색 오류율은 1% 미만으로 안정적이었고요. 여기서 중요한 건 단순 텍스트 매칭만 한 게 아니라, 공개 상태, 사이트 식별, 메뉴 권한까지 filter 절에 포함된 상태에서의 수치라는 점입니다. filter 절이 Elasticsearch 내부에서 캐싱되기 때문에 다차원 필터링을 추가해도 성능 저하가 크지 않았습니다.

---

## Q10. 이 구조에서 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재 Outbox 폴링 주기에 따라 색인 반영에 수 초의 지연이 있는데, Change Data Capture 방식을 도입하면 DB 변경을 더 빠르게 감지해서 준실시간 색인의 지연을 줄일 수 있을 것입니다. 둘째, 검색어 자동 완성이나 오타 교정 같은 검색 품질 향상 기능을 추가하고 싶습니다. Elasticsearch의 suggest API나 fuzzy 쿼리를 활용하면 사용자 검색 경험을 한 단계 더 올릴 수 있다고 생각합니다. 이런 개선을 통해 통합 검색 시스템의 실시간성과 검색 품질을 한 단계 더 높일 수 있을 것입니다.