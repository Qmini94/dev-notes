## Q1. 이 문제가 발생한 배경을 설명해 주세요.

동적 게시판 생성 서비스는 관리자가 UI에서 게시판을 정의하면 런타임에 세 가지가 동시에 만들어져야 합니다. 게시판 메타 정보를 저장하는 관리 테이블 레코드, 필드 구성을 저장하는 필드 관리 테이블 레코드, 그리고 실제 데이터가 담길 물리 테이블입니다. 이 세 가지가 항상 일관된 상태를 유지해야 하는데, DDL인 CREATE TABLE은 트랜잭션 롤백이 안 되고, 동시에 여러 관리자가 게시판을 만들 수도 있어서 데이터 무결성을 보장하는 게 생각보다 까다로운 문제였습니다.

---

## Q2. JVM Lock을 선택한 이유는 무엇인가요?

게시판 생성은 동시에 여러 요청이 들어왔을 때 테이블명 충돌이나 메타 데이터 경합이 발생할 수 있습니다. 이걸 막으려면 동시성 제어가 필요한데, 현재 단일 애플리케이션으로 운영되는 환경이기 때문에 분산 락까지 도입할 필요는 없었습니다. JVM 레벨의 Lock으로 게시판 생성 요청을 직렬화하면 충분히 경합을 방지할 수 있었습니다. 만약 다중 인스턴스 환경으로 확장된다면 Redis 기반 분산 락으로 전환해야 하겠지만, 현재 운영 환경에서는 JVM Lock이 가장 단순하고 확실한 선택이었습니다.

---

## Q3. DDL이 트랜잭션 롤백이 안 된다는 게 구체적으로 어떤 문제를 만드나요?

일반적인 DML인 INSERT나 UPDATE는 트랜잭션 안에서 실행되기 때문에, 중간에 에러가 나면 전체를 롤백할 수 있습니다. 그런데 DDL인 CREATE TABLE은 대부분의 DB에서 실행 즉시 커밋되거나 트랜잭션 롤백 대상이 아닙니다. 게시판 생성 흐름이 관리 테이블 INSERT, 필드 테이블 INSERT, 물리 테이블 CREATE 순서로 진행되는데, 앞의 두 단계까지 성공하고 세 번째에서 실패하면 DML은 롤백되지만 물리 테이블은 이미 없는 상태라 괜찮습니다. 반대로 물리 테이블까지 생성됐는데 그 이후 단계에서 실패하면, 물리 테이블은 이미 만들어진 채로 남아 있고 메타 데이터만 롤백되어 고아 테이블이 생기는 문제가 발생합니다.

---

## Q4. 보상 롤백은 어떤 구조로 구현했나요?

각 단계의 실행 결과를 추적하면서, 예외가 발생한 시점까지 성공한 단계를 역순으로 복구하는 방식입니다. 예를 들어 관리 테이블 INSERT 성공, 필드 테이블 INSERT 성공, 물리 테이블 CREATE 성공까지 됐는데 그 이후 인덱스 생성에서 실패했다면, 물리 테이블을 DROP하고 필드 테이블 레코드를 DELETE하고 관리 테이블 레코드를 DELETE하는 식으로 역순 복구합니다. 각 단계에서 어디까지 성공했는지를 플래그로 관리하고, catch 블록에서 해당 플래그를 확인해서 필요한 복구 작업만 수행합니다. 트랜잭션이 자동으로 해주는 걸 수동으로 구현한 것이라 볼 수 있습니다.

---

## Q5. 소유자 검증이란 구체적으로 어떤 건가요?

보상 롤백에서 물리 테이블을 DROP해야 하는 상황이 생기는데, 이때 DROP 대상이 정말 지금 이 요청에서 만든 테이블인지를 확인하는 검증입니다. 만약 검증 없이 테이블명만으로 DROP을 실행하면, 극단적인 경우에 동일한 이름의 기존 테이블을 잘못 삭제할 위험이 있습니다. 그래서 보상 롤백 시 해당 테이블이 현재 요청의 트랜잭션에서 생성된 것인지를 확인하고, 맞는 경우에만 DROP을 실행합니다. 기존에 이미 존재하던 테이블을 실수로 삭제하는 것을 방지하기 위한 안전장치입니다.

---

## Q6. 소유자 검증은 기술적으로 어떻게 구현했나요?

게시판 생성 과정에서 물리 테이블을 CREATE한 시점에 해당 테이블명을 현재 요청의 컨텍스트에 기록해둡니다. 보상 롤백이 필요해지면 DROP 대상 테이블명이 이 컨텍스트에 기록된 것인지를 먼저 확인합니다. 기록에 없으면 이 요청에서 만든 테이블이 아니라는 뜻이니까 DROP을 실행하지 않습니다. 추가로 DB 메타 정보를 조회해서 해당 테이블의 생성 시점이 현재 요청 시점과 근접한지도 교차 확인합니다. 이중으로 검증해서 기존 테이블의 오삭제를 방지했습니다.

---

## Q7. 이 세 가지 장치가 결합되어 동작하는 전체 흐름을 설명해 주세요.

게시판 생성 요청이 들어오면 먼저 JVM Lock을 획득합니다. Lock을 잡은 상태에서 관리 테이블 INSERT, 필드 테이블 INSERT, 물리 테이블 CREATE, 인덱스 생성 순서로 진행합니다. 각 단계 성공 여부를 플래그로 기록하고, 물리 테이블을 CREATE한 시점에 소유자 정보를 컨텍스트에 등록합니다. 모든 단계가 성공하면 Lock을 해제하고 정상 응답합니다. 중간에 어느 단계에서든 예외가 발생하면 보상 롤백으로 진입해서, 성공한 단계를 역순으로 복구합니다. DROP이 필요한 경우 소유자 검증을 통과한 테이블만 삭제합니다. 마지막에 Lock을 해제합니다. 이 세 가지가 결합되어 동시성, 일관성, 안전성을 모두 확보한 구조입니다.

---

## Q8. 이 경험에서 어떤 교훈을 얻었나요?

DDL과 DML이 혼합된 워크플로에서는 DB 트랜잭션만으로는 일관성을 보장할 수 없다는 것을 체감했습니다. 트랜잭션이 자동으로 해주던 보호를 수동으로 구현해야 하기 때문에, 각 단계의 실패 시나리오를 빠짐없이 고려해야 합니다. 특히 보상 롤백에서 잘못된 대상을 복구하면 오히려 더 큰 문제가 되기 때문에, 소유자 검증 같은 안전장치가 반드시 필요합니다. 동적으로 스키마를 변경하는 시스템을 만들 때는 이런 방어적 설계가 선택이 아니라 필수라는 걸 배웠습니다.