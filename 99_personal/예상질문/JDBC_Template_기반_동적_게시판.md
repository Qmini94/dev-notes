## Q1. 모든 게시판 데이터를 하나의 테이블에 넣지 않고 분리한 이유는 무엇인가요?

CMS 특성상 게시판 유형이 수십 개에 달하고, 클라이언트별로 5년 이상 운영되면서 게시글이 20만 건 이상 누적되는 환경입니다. 이걸 하나의 테이블에 전부 넣으면 LIKE 기반 검색이나 복합 검색 조건에서 병목이 생길 수밖에 없습니다. 또한 게시판 유형마다 필요한 컬럼이나 인덱스가 다른데, 단일 테이블에서는 유형별 최적화가 어렵습니다. 그래서 게시판 유형별로 독립된 테이블을 런타임에 생성하는 구조를 채택했습니다. 테이블이 분리되면 각 게시판의 데이터 규모가 관리 가능한 수준으로 유지되고, 테이블별로 최적화된 인덱스를 독립적으로 적용할 수 있어서 조회 성능이 크게 개선되었습니다.

---

## Q2. 런타임에 테이블을 생성한다는 건 구체적으로 어떤 방식인가요?

관리자가 UI에서 새 게시판 유형을 정의하면, 백엔드에서 그 설정 정보를 기반으로 DDL을 동적으로 생성해서 실행합니다. 게시판명을 테이블명에 매핑하고, 관리자가 정의한 필드 정보에 따라 컬럼 구성을 결정합니다. 기본 컬럼인 제목, 내용, 작성자, 작성일 같은 건 공통으로 포함되고, 그 외에 관리자가 추가한 커스텀 필드가 컬럼으로 반영됩니다. 테이블 생성 후에는 기본 인덱스도 함께 생성합니다. 이 과정이 전부 런타임에 이루어지기 때문에 코드 배포 없이 새 게시판을 바로 운영할 수 있습니다.

---

## Q3. JPA 대신 JDBC Template을 선택한 이유는 무엇인가요?

JPA는 엔티티 클래스를 기반으로 동작하기 때문에, 런타임에 테이블이 동적으로 생성되는 구조와는 근본적으로 맞지 않습니다. 엔티티가 컴파일 타임에 확정되어야 하는데, 게시판 유형마다 컬럼 구성이 다르고 운영 중에도 추가될 수 있으니까요. JDBC Template은 SQL을 직접 제어할 수 있어서 테이블명, 컬럼명, 조건절을 동적으로 구성하는 데 제약이 없습니다. DDL 실행도 자유롭고, 동적 SQL 빌더를 만들어서 검색 조건이나 정렬 조건을 런타임에 조합할 수 있어서 이 프로젝트의 요구사항에 가장 적합했습니다.

---

## Q4. 동적 SQL 빌더는 어떤 구조로 설계했나요?

게시판 설정 정보를 입력으로 받아서 SELECT, INSERT, UPDATE, DELETE 쿼리를 동적으로 조립하는 빌더 클래스를 만들었습니다. 테이블명은 게시판 식별자를 기반으로 결정되고, 컬럼 목록은 해당 게시판의 필드 설정에서 가져옵니다. 검색 조건은 프론트엔드에서 전달받은 파라미터를 기반으로 WHERE절을 동적으로 구성하고, 정렬이나 페이지네이션도 파라미터에 따라 조합합니다. SQL Injection을 방지하기 위해 사용자 입력값은 반드시 파라미터 바인딩을 사용하고, 테이블명이나 컬럼명 같은 식별자는 허용 목록 기반으로 검증한 뒤에만 쿼리에 포함시킵니다.

---

## Q5. SQL Injection 방어를 좀 더 구체적으로 설명해 주세요.

동적 SQL에서 가장 주의해야 할 부분이 SQL Injection인데, 두 가지 레이어로 방어했습니다. 첫째, 사용자가 입력한 검색어나 값은 전부 JDBC Template의 파라미터 바인딩을 통해 전달합니다. 이러면 입력값이 SQL 구문으로 해석되는 게 원천적으로 차단됩니다. 둘째, 테이블명이나 컬럼명은 파라미터 바인딩이 안 되기 때문에, DB에 등록된 게시판 설정의 필드 목록과 대조해서 허용된 식별자만 쿼리에 포함시킵니다. 사용자 입력이 직접 테이블명이나 컬럼명에 들어가는 경로는 없도록 설계했습니다.

---

## Q6. 테이블이 동적으로 늘어나면 관리가 어렵지 않나요?

맞습니다. 테이블 수가 늘어나면 스키마 관리나 마이그레이션이 복잡해질 수 있습니다. 이 부분은 게시판 설정 테이블이 메타 정보 역할을 하면서 관리합니다. 어떤 게시판이 어떤 테이블에 매핑되고, 어떤 필드를 가지고 있는지를 설정 테이블에서 일괄 관리하기 때문에, 물리적으로 테이블이 분산되어 있어도 논리적으로는 중앙에서 추적이 가능합니다. 또한 게시판별 독립 테이블이기 때문에 한 게시판의 스키마 변경이 다른 게시판에 영향을 주지 않아서, 오히려 단일 테이블일 때보다 변경 영향 범위가 줄어드는 장점도 있었습니다.

---

## Q7. 프론트엔드 테마 렌더링 엔진과는 어떻게 연결되나요?

관리자가 게시판을 정의하면 백엔드에서는 동적 테이블을 생성하고 CRUD를 처리하고, 프론트엔드에서는 그 설정에 명시된 테마로 컴포넌트를 동적 렌더링합니다. 프론트엔드가 렌더 데이터 API를 호출하면 해당 게시판의 유형, 필드 구성, 테마 정보가 내려오고, 이걸 기반으로 리스트, 검색박스, 상세보기 같은 컴포넌트가 결정됩니다. 백엔드의 동적 테이블 엔진과 프론트엔드의 테마 렌더링 엔진이 게시판 설정이라는 하나의 메타 데이터를 공유하면서 연결되는 구조라서, 코드 배포 없이 관리자 설정만으로 새 게시판이 완성됩니다.

---

## Q8. Elasticsearch와는 어떻게 연계되나요?

게시판별로 테이블이 분리되어 있으니까 일반 SQL로는 여러 게시판에 걸친 통합 검색이 어렵습니다. 이 한계를 Elasticsearch로 해결했습니다. 각 게시판 테이블의 데이터를 Elasticsearch에 색인할 때, 게시판 식별자를 메타 필드로 포함시켜서 하나의 인덱스에서 전체 게시판 데이터를 통합 검색할 수 있도록 했습니다. 사용자 입장에서는 하나의 검색창에서 모든 게시판의 콘텐츠를 검색할 수 있고, 필요하면 게시판 유형으로 필터링도 가능합니다. 동적 테이블로 인한 데이터 분산이라는 트레이드오프를 Elasticsearch가 보완해주는 구조입니다.

---

## Q9. 이 구조에서 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재 스키마 변경 시 기존 테이블에 ALTER를 실행하는 방식인데, 변경 이력을 관리하는 마이그레이션 체계를 도입하면 스키마 변경 추적과 롤백이 더 안전해질 것입니다. 둘째, 동적 SQL 빌더가 범용성을 위해 단일 클래스로 구현되어 있는데, 게시판 유형별로 특화된 쿼리 전략을 플러그인처럼 확장할 수 있는 구조로 발전시키면 복잡한 조회 요구사항에 더 유연하게 대응할 수 있다고 생각합니다. 이런 개선을 통해 동적 게시판 엔진의 확장성과 운영 안정성을 한 단계 더 높일 수 있을 것입니다.