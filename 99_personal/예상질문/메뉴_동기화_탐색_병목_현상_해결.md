## Q1. 병목을 어떻게 발견했나요?

커스텀 어노테이션으로 만든 ExecutionTime이라는 AOP 기반 실행 시간 측정 도구가 있었습니다. 메서드 단위로 실행 시간을 로깅하는 건데, 메뉴 트리 동기화 메서드가 500ms를 초과하는 게 반복적으로 찍혔습니다. 메뉴 동기화는 관리자가 메뉴 구조를 변경할 때 실행되는 작업인데, 500ms면 사용자 체감상 느리다고 느낄 수 있는 수준이었습니다. 로그를 더 세분화해서 확인해보니, 트리 탐색과 DB 저장이 노드 하나하나에 대해 개별적으로 이루어지면서 DB 호출 횟수가 노드 수에 비례해서 늘어나는 게 원인이었습니다.

---

## Q2. 기존 DFS 방식의 구체적인 문제는 무엇이었나요?

기존에는 깊이 우선 탐색으로 메뉴 트리를 순회하면서, 각 노드를 방문할 때마다 해당 노드의 정보를 DB에 저장하고 경로 정보를 갱신했습니다. 노드가 50개면 DB 호출이 50번 이상 나가는 구조였습니다. DFS 특성상 한 노드를 처리하고, 그 자식으로 내려가고, 다시 올라와서 형제를 처리하는 식이라 배치 처리가 어렵습니다. 특히 pathId 같은 경로 정보를 갱신하려면 부모의 경로를 먼저 알아야 하는데, DFS에서는 부모 처리가 끝나야 자식을 처리할 수 있으니까 노드별 순차 처리를 피할 수가 없었습니다.

---

## Q3. BFS로 전환하면 왜 배치 처리가 가능해지나요?

BFS는 같은 깊이의 노드를 한꺼번에 처리하는 방식입니다. 1단계 노드를 전부 처리하고, 2단계 노드를 전부 처리하고, 이런 식으로 레벨 단위로 진행합니다. 같은 깊이의 노드들은 부모가 이미 이전 단계에서 처리 완료된 상태이기 때문에, 부모의 pathId를 참조해서 자기 pathId를 계산하는 게 가능합니다. 이렇게 같은 깊이의 노드들을 모아서 한 번에 배치 저장하고, pathId도 CONCAT 쿼리로 일괄 갱신하면 DB 호출 횟수가 노드 수가 아니라 트리 깊이에 비례하게 됩니다. 트리가 5단계이면 대략 5번 정도의 DB 호출로 끝나는 것입니다.

---

## Q4. CONCAT 쿼리로 pathId를 일괄 갱신한다는 건 어떤 의미인가요?

같은 깊이의 노드들을 배치 저장한 뒤, 해당 노드들의 pathId를 한 번의 UPDATE 쿼리로 갱신하는 방식입니다. 부모의 pathId에 자기 ID를 dot으로 이어붙이는 연산을 DB의 CONCAT 함수로 처리합니다. 예를 들어 부모 pathId가 "1.3"이고 자식 ID가 8이면 "1.3.8"이 되는 식인데, 이걸 노드 하나씩 UPDATE하는 게 아니라 같은 깊이의 노드 전체에 대해 한 번의 쿼리로 실행합니다. 이전에는 노드마다 애플리케이션에서 pathId를 계산해서 개별 UPDATE를 날렸는데, DB 레벨에서 일괄 처리하면 네트워크 왕복과 쿼리 실행 오버헤드가 크게 줄어듭니다.

---

## Q5. 500ms에서 150ms로 개선된 수치는 어떻게 측정했나요?

동일한 ExecutionTime 어노테이션으로 개선 전후를 비교했습니다. 동일한 메뉴 트리 구조를 대상으로 동기화를 실행해서 실행 시간을 측정했고, 여러 번 반복해서 평균을 냈습니다. 개선 전에는 노드 수에 따라 500ms에서 그 이상까지 걸렸는데, BFS와 배치 처리 적용 후에는 같은 데이터 기준으로 150ms 수준으로 떨어졌습니다. 약 70% 개선인데, DB 호출 횟수가 노드 수 비례에서 트리 깊이 비례로 바뀐 게 가장 큰 요인이었습니다.

---

## Q6. pathId 도입이 이 문제 해결에 어떻게 기여했나요?

pathId가 없었을 때는 경로 정보를 알기 위해 매번 부모를 재귀적으로 조회해야 했습니다. 동기화 과정에서도 노드의 경로를 계산하려면 부모 체인을 타고 올라가는 추가 쿼리가 필요했고, 이게 DFS와 결합되면서 DB 호출이 더 늘어났습니다. pathId를 도입하면 부모의 pathId에 자기 ID만 붙이면 되니까 경로 계산이 단순 문자열 연산으로 바뀝니다. BFS에서 레벨별로 처리할 때 이전 레벨에서 이미 pathId가 확정된 상태이므로, 다음 레벨의 pathId를 CONCAT 한 번으로 일괄 생성할 수 있게 된 것입니다. 탐색 알고리즘 변경과 데이터 모델 변경이 함께 작용해서 개선 효과가 극대화되었습니다.

---

## Q7. 이 개선이 다른 기능에도 영향을 준 부분이 있나요?

pathId 도입은 메뉴 동기화만이 아니라 권한 상속 조회에도 활용되었습니다. 앞서 말씀드린 상속 권한 조회 최적화에서 재귀 쿼리를 제거한 것도 이 pathId 덕분입니다. 메뉴 동기화 병목을 해결하면서 도입한 pathId가 권한 조회 성능까지 함께 개선하는 결과로 이어진 것입니다. 하나의 데이터 모델 변경이 여러 기능의 성능을 동시에 개선한 사례라서, 근본적인 데이터 구조 설계가 얼마나 중요한지를 체감할 수 있었습니다.

---

## Q8. 이 경험에서 어떤 교훈을 얻었나요?

두 가지 교훈이 있었습니다. 첫째, 성능 문제는 측정 없이는 발견할 수 없다는 점입니다. ExecutionTime 같은 간단한 측정 도구라도 미리 붙여두면 병목을 조기에 발견할 수 있습니다. 둘째, 알고리즘 변경만으로는 한계가 있고 데이터 모델 변경과 함께 가야 효과가 크다는 점입니다. DFS에서 BFS로만 바꿨으면 개선 폭이 제한적이었을 텐데, pathId 도입과 CONCAT 일괄 갱신까지 결합하면서 DB 호출 구조 자체가 바뀌어 70% 개선이 가능했습니다.