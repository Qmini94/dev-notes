## Q1. 동적 게시판 렌더링의 전체 구조를 설명해 주세요.

게시판 유형마다 별도의 페이지를 만드는 게 아니라, 하나의 게시판 라우트에서 유형에 따라 다른 테마 컴포넌트를 동적으로 조합하는 구조입니다. 렌더 데이터에 게시판 유형 정보가 들어 있고, 그 정보를 기반으로 리스트, 검색박스, 페이지네이션 같은 컴포넌트를 런타임에 결정합니다. Vue의 동적 컴포넌트 기능을 활용해서 테마별 컴포넌트를 교체하고, list, view, write 모드에 따라 조합을 달리해서 하나의 진입점으로 수십 가지 게시판 유형을 처리할 수 있도록 설계했습니다.

---

## Q2. 테마 컴포넌트의 디렉토리 구조와 로딩 방식은 어떻게 되나요?

테마별로 디렉토리를 나누고, 각 디렉토리 안에 리스트, 검색박스, 페이지네이션 같은 역할별 컴포넌트를 배치했습니다. 예를 들어 gallery 테마라면 gallery 폴더 안에 List, Search 같은 컴포넌트가 들어가는 식입니다. 로딩은 import.meta.glob으로 테마명을 키로 동적 resolve하는 방식이고요. 이렇게 하면 빌드 설정이나 라우터를 건드리지 않아도 테마 폴더에 컴포넌트 파일만 추가하면 자동으로 인식되기 때문에, 신규 게시판 유형을 추가할 때 코드 변경을 최소화할 수 있었습니다.

---

## Q3. list, view, write 모드 전환은 어떻게 처리하나요?

URL 쿼리의 mode 값으로 현재 모드를 판별하고, 모드에 따라 렌더링할 컴포넌트 조합을 결정합니다. list 모드에서는 리스트, 검색박스, 페이지네이션을 조합하고, view 모드에서는 상세 보기를, write 모드에서는 에디터를 렌더링합니다. 권한 검사는 앞단의 미들웨어에서 mode별로 이미 처리한 상태이기 때문에, 컴포넌트 레벨에서 권한 로직을 중복으로 넣을 필요가 없습니다. 모드가 바뀌어도 라우트 이동 없이 같은 페이지에서 컴포넌트만 교체되기 때문에 전환이 매끄럽습니다.

---

## Q4. 백엔드의 동적 게시판 CRUD 서비스와는 어떻게 연결되나요?

백엔드에서도 게시판 유형마다 별도 컨트롤러를 만들지 않고, 하나의 범용 CRUD 서비스가 게시판 설정 테이블을 참조해서 동적으로 동작합니다. 관리자가 UI에서 새 게시판 유형을 정의하면 설정이 DB에 저장되고, 프론트엔드는 렌더 데이터 API를 통해 그 설정을 받아서 테마 컴포넌트를 결정합니다. 결과적으로 관리자가 게시판을 정의하면 백엔드는 설정 기반으로 CRUD를 처리하고, 프론트엔드는 해당 테마로 렌더링하기 때문에 코드 배포 없이 새 게시판을 바로 운영할 수 있는 구조입니다.

---

## Q5. 존재하지 않는 테마가 지정됐을 때는 어떻게 되나요?

폴백 처리를 해뒀습니다. 동적 컴포넌트를 resolve할 때 해당 테마 폴더에 컴포넌트가 없으면 기본 테마의 컴포넌트를 대신 렌더링합니다. 그래서 관리자가 아직 구현되지 않은 테마명을 설정하더라도 에러 페이지가 아니라 기본 형태의 게시판이 나옵니다. 레이아웃 선택 미들웨어에서 레이아웃 파일이 없을 때 default로 폴백하는 것과 같은 원칙인데, 시스템 전반에 걸쳐 이런 안전장치를 일관되게 적용했습니다.

---

## Q6. 이 구조에서 성능은 어떻게 고려했나요?

수십 가지 테마 컴포넌트를 전부 초기 번들에 넣으면 번들 크기가 불필요하게 커집니다. 그래서 동적 import를 활용한 코드 스플리팅을 적용했습니다. 해당 게시판 유형이 실제로 렌더링될 때만 관련 컴포넌트를 비동기로 로딩하기 때문에, 초기 로딩에 필요한 JavaScript 번들을 최소화할 수 있었습니다. 한 번 로딩된 테마 컴포넌트는 캐싱되어서 같은 유형의 게시판을 다시 방문할 때 추가 로딩 없이 바로 렌더링됩니다.

---

## Q7. 게시판 유형이 수십 개면, 테마 간 공통 로직 중복은 어떻게 관리하나요?

테마 컴포넌트는 UI 렌더링만 담당하고, 데이터 페칭이나 페이지네이션 로직 같은 공통 기능은 Composable로 분리해서 공유합니다. 예를 들어 목록 조회, 페이지 전환, 검색 조건 처리 같은 건 useBoardList 같은 Composable에 집약하고, 각 테마 컴포넌트는 그걸 호출해서 받은 데이터를 자기 방식으로 표현하기만 합니다. 이렇게 하면 새 테마를 추가할 때 비즈니스 로직을 다시 구현할 필요 없이 UI 컴포넌트만 작성하면 되기 때문에, 개발 효율과 코드 일관성을 동시에 확보할 수 있었습니다.

---

## Q8. 이 구조에서 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재는 테마 컴포넌트 존재 여부를 런타임에 확인하는데, 빌드 타임에 테마 디렉토리를 검증해서 누락된 컴포넌트를 미리 감지하는 체계를 추가하면 운영 안정성을 높일 수 있을 것입니다. 둘째, 테마별 컴포넌트가 지켜야 할 인터페이스가 암묵적으로 관리되고 있는데, TypeScript 인터페이스로 명시적인 계약을 정의하면 테마 간 호환성을 보장하고 협업 시 실수를 줄일 수 있다고 생각합니다. 이런 개선을 통해 동적 게시판 시스템의 확장성과 안정성을 한 단계 더 높일 수 있을 것입니다.