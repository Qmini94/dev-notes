## Q1. JWT 단독이 아니라 Redis를 결합한 이유는 무엇인가요?

JWT는 Stateless 특성 덕분에 서버 확장에 유리하지만, 한번 발급된 토큰을 서버에서 강제로 무효화할 수 없다는 구조적 한계가 있습니다. 그런데 운영 요구사항으로 강제 로그아웃, 권한 변경 즉시 반영, 슬라이딩 세션이 있었기 때문에 JWT만으로는 충족이 어려웠습니다. 그래서 JWT는 클라이언트와 서버 간 인증 정보 전달과 무결성 검증을 담당하게 하고, Redis는 세션 상태와 권한 생명주기를 관리하는 역할을 맡겨서 Stateless의 이점은 유지하면서 서버 주도의 세션 제어가 가능한 구조를 만들었습니다.

---

## Q2. 블랙리스트 방식 대신 화이트리스트 방식을 채택한 이유는 무엇인가요?

전통적인 JWT 시스템에서는 무효화된 토큰을 블랙리스트에 등록해서 차단하는 방식을 씁니다. 그런데 이 방식은 블랙리스트가 계속 누적되고, 매 요청마다 블랙리스트를 조회해야 하는 부담이 있습니다. 저희는 이걸 역전시켜서, 유효한 세션만 Redis에 저장하고 세션이 존재하지 않으면 무효로 간주하는 화이트리스트 방식을 채택했습니다. 로그아웃이나 강제 만료 시 Redis 세션을 삭제하기만 하면 다음 요청에서 바로 인증이 실패하기 때문에 별도의 블랙리스트 관리가 불필요하고, 로직도 단순해집니다.

---

## Q3. 인증 흐름을 구체적으로 설명해 주세요.

클라이언트가 API 요청을 보내면 브라우저가 HttpOnly 쿠키에 담긴 Access Token을 자동으로 함께 전송합니다. Spring Security 인증 필터가 이 요청을 가로채서 먼저 JWT 서명과 만료 시간을 검증합니다. 검증이 통과하면 JWT Payload에 포함된 SID를 기반으로 Redis에서 세션을 조회합니다. 세션이 존재하면 인증 성공으로 처리하고, 슬라이딩 방식으로 세션 TTL을 갱신한 뒤 SecurityContext에 인증 정보를 설정합니다. 만약 Access Token이 유효하더라도 Redis 세션이 만료됐거나 삭제된 상태라면 인증 실패로 처리합니다. 이게 핵심인데, 토큰이 아니라 Redis 세션의 존재 여부가 최종 인증 판단 기준이 됩니다.

---

## Q4. 슬라이딩 세션은 어떻게 구현했나요?

Redis 세션의 TTL을 기본 1시간으로 설정하고, 인증에 성공한 API 요청이 들어올 때마다 그 TTL을 갱신하는 방식입니다. 사용자가 활동하고 있으면 계속 세션이 연장되고, 일정 시간 동안 요청이 없으면 자연스럽게 만료됩니다. 프론트엔드 쪽에서는 로그인 시 서버가 내려주는 세션 만료 시각을 기반으로 자동 로그아웃 타이머를 설정합니다. 이 만료 시각은 HttpOnly가 아닌 일반 쿠키와 응답 헤더 두 곳으로 전달하는데, 이 값은 클라이언트 UX용이고 실제 인증 판단에는 사용되지 않습니다. 사용자가 이 값을 조작하더라도 서버의 Redis TTL이 최종 기준이기 때문에 보안에는 영향이 없습니다.

---

## Q5. 다중 로그인 환경에서 강제 로그아웃은 어떻게 처리하나요?

사용자별로 활성 세션을 추적하기 위해 Redis에 인덱싱 구조를 만들어뒀습니다. 사용자가 로그인하면 해당 SID가 그 사용자의 세션 SET에 추가됩니다. 강제 로그아웃이나 권한 변경이 필요하면 해당 사용자의 세션 SET에서 모든 SID를 조회하고, 각 SID에 해당하는 Redis 세션을 일괄 삭제합니다. Access Token과 Refresh Token이 동일한 SID를 공유하기 때문에, 세션 하나를 삭제하면 그 세션과 연결된 모든 토큰이 동시에 무효화됩니다. 비밀번호 변경, 권한 변경, 계정 정지, 탈퇴 같은 이벤트에서 모두 이 방식으로 처리합니다.

---

## Q6. Refresh Token 재발급은 어떤 조건에서 허용되나요?

세 가지 조건을 모두 만족해야 합니다. Redis가 정상 상태여야 하고, Refresh Token 자체가 유효해야 하고, 그 토큰의 SID에 해당하는 Redis 세션이 존재해야 합니다. 이 세 가지를 모두 통과하면 새 Access Token을 발급하고, Redis 세션 TTL을 갱신하고, 세션 만료 시각도 다시 계산해서 클라이언트에 전달합니다. 반대로 하나라도 실패하면 401을 반환합니다. 이렇게 설계한 이유는 Refresh Token이 탈취되더라도 Redis 세션이 없으면 재발급 자체가 불가능하게 만들어서, 토큰 단독 사용으로 인한 무제한 접근을 원천 차단하기 위해서입니다.

---

## Q7. Redis 장애 시 Graceful Degradation은 어떻게 동작하나요?

Health Check를 통해 Redis 접속 불가나 타임아웃을 감지하면 장애 대응 모드로 전환됩니다. 이 모드에서는 Redis 세션 검증을 건너뛰고, 기존에 발급된 Access Token의 서명과 만료 시간만으로 제한적인 인증을 수행합니다. 다만 권한 정보를 Redis에서 조회할 수 없으니까, 모든 사용자를 최소 권한으로 강등해서 처리합니다. 관리자 기능이나 민감한 권한이 필요한 요청은 전부 제한됩니다. Redis 장애가 해소되면 자동으로 정상 모드로 복귀합니다. 보안 수준이 일시적으로 낮아지는 트레이드오프가 있지만, Redis 장애가 곧 서비스 전체 중단으로 이어지는 것보다는 낫다고 판단했습니다.

---

## Q8. 토큰을 쿠키로 관리하는 이유와 보안 정책을 설명해 주세요.

LocalStorage나 SessionStorage에 토큰을 저장하면 XSS 공격 시 JavaScript로 직접 탈취가 가능합니다. 그래서 Access Token과 Refresh Token 모두 HttpOnly 쿠키로 관리해서 브라우저의 JavaScript 환경에서 토큰 값에 접근할 수 없게 했습니다. 추가로 Secure 속성을 적용해서 HTTPS에서만 전송되게 하고, SameSite는 Lax로 설정해서 크로스 사이트 요청에서의 쿠키 자동 전송을 제한했습니다. SSR과 CSR이 혼합된 환경에서 인증 쿠키가 안정적으로 전달되면서도 CSRF 공격 가능성을 완화하기 위해 Lax를 선택한 것입니다. 로그인 엔드포인트는 CSRF 검증 예외로 처리했습니다.

---

## Q9. 프론트엔드에서 세션 만료 시각 동기화는 어떻게 처리하나요?

로그인 성공 시 서버가 Redis 세션 생성 시점 기준으로 만료 시각을 계산해서, HttpOnly가 아닌 일반 쿠키와 응답 헤더 두 곳으로 내려줍니다. 프론트엔드는 이 값을 읽어서 자동 로그아웃 타이머를 설정합니다. API 요청으로 세션 TTL이 갱신될 때마다 만료 시각도 다시 계산해서 전달하기 때문에, 클라이언트 타이머와 서버 세션 상태 간의 시간 차이를 최소화할 수 있었습니다. 중요한 건 이 만료 시각 값은 순수하게 UX 목적이고, 사용자가 조작하더라도 서버의 Redis TTL이 최종 기준이기 때문에 보안에는 영향을 주지 않는다는 점입니다.

---

## Q10. 이 아키텍처의 한계나 개선하고 싶은 점이 있다면 무엇인가요?

두 가지를 개선하고 싶습니다. 첫째, 현재 JWT 서명 키 변경 시 기존에 발급된 모든 토큰이 무효화되는 구조인데, 키 롤링이나 다중 키 검증을 도입하면 키 교체 시에도 기존 사용자 세션을 유지할 수 있을 것입니다. 둘째, 토큰 위변조 탐지 시 로그 기록만 하고 있는데, 실시간 알림이나 특정 IP 패턴에 대한 자동 차단 기능을 추가하면 보안 대응력을 높일 수 있다고 생각합니다. 이런 개선을 통해 인증 시스템의 운영 안정성과 보안 수준을 한 단계 더 높일 수 있을 것입니다.