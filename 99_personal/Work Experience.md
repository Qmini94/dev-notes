<p align="right">박 규 민</p>
(주)유비 (2024.01 ~ 재직 중)

- 직위: 연구원
- 역할: 레거시 CMS 솔루션의 리빌딩과 모던 기술 스택으로의 마이그레이션을 주도하며, 시스템설계 및 개발을 수행합니다. 또한 조직도 도메인의 전반적인 개발 및 운영을 담당합니다.
- 주요 책임:
	1. 레거시 시스템의 현대화 설계 및 마이그레이션 개발
	2. 조직도 도메인 기능 개발 및 유지보수
	3. 폐쇄망-외부망 보안 데이터 연동 및 ETL 프로세스 수립
- 주목할만한 성과:
	1. 아키텍처 고도화 및 운영 안정성 확보
		- 무중단 배포 파이프라인 구축으로 배포 다운타임 제로 달성
		- 하이브리드 인증 아키텍처 설계로 인증 부하 최소화 및 장애 시 서비스 가용성 확보
		- JPA/QueryDSL/JDBC 선택적 적용으로 도메인별 데이터 처리 효율 극대화
	2. 웹 성능 최적화 및 사용자 경험 개선
		- SSR/CSR 하이브리드 렌더링으로 Lighthouse 성능 점수 93점 달성
		- 계층형 상속 권한 조회 쿼리 수 75% 감소 및 응답 속도 10배 이상 개선
	3. 데이터 처리 시스템 및 기능 확장
		- Elasticsearch 도입 및 Transactional Outbox 기반 색인 동기화로 검색 정확도, 데이터 일관성 동시 확보
		- 런타임 동적 스키마(DDL) 제어 엔진 개발로 관리자 자율 데이터 구조 운영 실현

**[LLM 기반 설계·개발 프로세스 도입 및 워크플로 구축]**
AI 기반 개발 역량 확보가 조직 내 요구되었으나, CLI 환경에서 LLM을 실질적인 설계, 개발 워크플로에 적용한 경험자가 없어 주도적으로 프로세스 도입을 진행했습니다. BMad 에이전트 프레임워크와 Claude Code CLI를 활용해 요구사항 정의, 아키텍처 설계, API 계약, 이벤트 흐름을 MD 산출물 중심으로 표준화하고, 에이전트, 페르소나, 스킬 기반 규칙 체계를 수립했습니다.

LLM이 생성한 설계 및 코드 초안은 그대로 채택하지 않고, 도메인 제약 조건, 인터페이스 정합성, 비기능 요구사항(성능·장애·권한) 누락 여부를 점검하는 검증 프로세스를 구축했습니다. 이를 통해 AI 산출물을 단순 보조 도구가 아닌 검증 가능한 설계, 개발 입력물로 활용하는 체계를 마련했습니다.

그 결과, 설계 산출물 작성 리드타임을 단축하고 인터페이스 변경에 따른 재작업을 감소시켰으며, 설계 의사결정 일관성을 확보하여 신규 기능 확장 시 안정적인 구조 확장을 가능하게 했습니다.

**[CI/CD 파이프라인 구축 및 무중단 배포]**
백엔드와 프론트엔드 각각에 독립된 Jenkins 파이프라인을 구성하여 빌드, 아카이빙, 배포를 자동화했습니다. CI(빌드 및 아카이빙)와 CD(배포)를 별도 파이프라인으로 분리하여, 빌드 아티팩트를 검증한 후 승인을 거쳐 배포하는 구조를 채택했습니다.

배포에는 Blue/Green 전략을 적용했습니다. 운영 서버에서 현재 활성 포트를 확인한 뒤 반대 포트에 새 버전을 기동하고, Health Check가 통과하면 Apache의 업스트림 설정 파일을 교체하고 graceful restart로 트래픽을 무중단 전환합니다. 전환 완료 후 이전 포트의 프로세스를 종료하며, 실패 시 이전 릴리스 디렉토리가 보존되어 즉시 롤백이 가능합니다.

그 결과,  배포 시 사용자에게 서비스 중단 없이 새 버전이 반영되어 운영 안정성과 사용자 경험을 상승 시켰습니다.

**[JWT+Redis 하이브리드 인증 아키텍처 설계]**
JWT는 Stateless 특성을 통해 분산 환경에서의 확장성을 제공하나, 토큰 자체의 독립성으로 인해 강제 로그아웃이나 권한 변경의 즉시 반영이 불가능한 구조적 한계가 있습니다. 전통적인 JWT 시스템은 무효 토큰을 블랙리스트로 관리하지만, 본 시스템은 이를 역전시켜 유효한 세션만 Redis에 저장하는 화이트리스트 방식을 채택했습니다. JWT는 인증 정보 전달 및 무결성 검증을, Redis는 세션 상태 및 권한 생명주기 관리를 담당하여 Stateless 아키텍처의 이점을 유지하면서 엔터프라이즈 수준의 세션 제어를 구현했습니다.

Access Token(15분)과 Refresh Token(24시간) 이중 구조로 구성하며, 양 토큰 모두 동일한 세션 ID를 공유하여 Redis Session 삭제만으로 모든 토큰이 동시 무효화됩니다. 토큰은 HttpOnly, Secure, SameSite 쿠키로 전달하여 XSS를 통한 탈취를 원천 차단합니다. 인증 필터가 매 요청마다 Redis Session 존재 여부를 확인하고 슬라이딩 TTL을 갱신하며, 사용자 단위 세션 인덱스(SET 자료형)로 다중 로그인 환경에서 특정 사용자의 모든 세션을 일괄 무효화할 수 있습니다. Redis 장애 시에는 Graceful Degradation으로 전환하여 JWT 자체의 서명 및 만료 시간 검증만으로 제한적 인증을 수행하되, 모든 사용자를 최소 권한으로 강등하여 보안 수준을 유지합니다. Redis 장애가 해소되면 자동으로 정상 모드로 복귀합니다.

그 결과, 슬라이딩 세션, 강제 로그아웃, 권한 변경 즉시 반영, 계정 잠금이라는 운영 요구사항을 충족하면서도 Redis 장애 시에도 서비스 가용성을 유지하는 인증 체계를 구축했습니다. 세션 만료 시각을 프론트엔드에 전달하여 클라이언트 측 자동 로그아웃 타이머와 서버 인증 상태 간의 동기화를 확보했습니다.

**[Nuxt 3 SSR/CSR 하이브리드 렌더링 전략 설계]**
공개 페이지는 SEO와 초기 로딩 속도를 위해 서버 사이드 렌더링이 필요하고, 관리자 페이지는 인증이 필수이므로 클라이언트 사이드 렌더링이 적합합니다. Next.js도 검토했으나, Vue 생태계의 러닝커브와 SSR 지원 성숙도를 평가하여 Nuxt 3을 선택했습니다. SPA 전용은 SEO 불가, SSR 전용은 관리자 화면의 복잡한 상태 관리에 부적합하여 하이브리드 전략을 설계했습니다.

서버 플러그인에서 정적 리소스 경로를 정규식으로 감지하여 SSR 초기화를 스킵하고, 운영 환경에서는 Apache가 정적 리소스를 디스크에서 직접 서빙하므로 이 로직은 개발 환경 가드 역할만 수행합니다. SSR은 서버 렌더링 비용이 추가되어 동시 접속 증가 시 Node.js 프로세스 부하가 증가하며, 이를 완화하기 위해 Vue Query 캐시로 불필요한 SSR 데이터 패칭을 최소화했습니다.

이 하이브리드 구조 위에 5계층 미들웨어 파이프라인(IP 접근 제어, 인증, 메뉴 관리, 렌더 권한, 레이아웃 선택), 통합 API 레이어(safeFetch), 동적 테마 렌더링 엔진이 구축되어 전체 프론트엔드 아키텍처의 기반이 됩니다.

**[동적 게시판 테마 렌더링 엔진]**
30종 이상의 게시판 유형을 각각 별도 페이지로 구현하면 코드 중복이 극심하고, 새 유형 추가마다 라우터 등록과 빌드 설정 변경이 필요합니다. 이를 해결하기 위해 단일 catch-all 라우터에서 모든 게시판 유형을 동적으로 렌더링하는 엔진을 설계했습니다.

catch-all 라우터가 렌더 데이터의 type에 따라 Board 또는 Content 컴포넌트를 비동기 코드 스플리팅으로 로드합니다. Board 컴포넌트는 게시판 유형별 테마 컴포넌트(리스트, 검색박스, 페이지네이션)를 조합하여 list, view, write 모드를 동적 렌더링합니다. 메뉴 ID와 렌더 데이터를 기반으로 컴포넌트 키를 생성하여 Vue의 컴포넌트 재사용 캐시 충돌을 방지합니다.

이 구조를 통해 신규 게시판 테마 추가 시 테마 디렉토리에 컴포넌트만 추가하면 되고, 라우터나 빌드 설정 변경이 불필요합니다. 백엔드 동적 게시판 CRUD 엔진과 결합하여 코드 변경 없이 관리자 UI에서 새 게시판 유형을 정의하면 즉시 운영할 수 있는 완전한 동적 게시판 시스템을 구현했습니다.

**[JPA + QueryDSL 조합의 타입 안전 동적 쿼리 구현]**
정적 CRUD에는 Spring Data JPA가 적합하지만, 관리자 화면의 다중 조건 검색(키워드, 날짜 범위, 상태, 정렬)에서는 문자열 기반 쿼리 방식이 조건 분기로 인해 가독성이 급격히 저하됩니다. JPA Criteria API도 검토했으나 가독성이 QueryDSL보다 현저히 떨어져, QueryDSL을 선택했습니다.

JPAQueryFactory를 Bean으로 등록하고, Repository 구현체에서 Q-클래스 기반 타입 안전 쿼리를 구성합니다. Gradle에서 QueryDSL Q-클래스 생성 태스크와 MapStruct 어노테이션 프로세서가 충돌하여 빌드 실패가 반복되었으며, annotationProcessor 순서를 명시하고 generated 소스 디렉토리를 분리하여 해결했습니다.

QueryDSL은 라이브러리 유지보수 불확실성(5.x 릴리스 지연)이 있으나, Spring Data JPA와의 통합이 성숙하고 현재 프로젝트 규모에서 충분히 안정적입니다. JPA + QueryDSL 조합은 CRUD 도메인(사이트, 멤버, 게시판 마스터, 콘텐츠)에 적용하고, 동적 게시판처럼 JPA 매핑이 불가능한 영역은 JDBC Template으로 분리했습니다.

**[JDBC Template 기반 동적 게시판 CRUD 엔진 — 대용량 테이블 분리 전략]**
실제 운영 중인 클라이언트의 레거시 CMS에서 정적 게시판 단일 테이블에 20만 건 이상의 게시글이 축적되어, 테이블 복사(마이그레이션)가 타임아웃으로 실패하고 LIKE 검색 응답이 수 초 이상 소요되는 성능 병목이 발생했습니다. 근본 원인은 모든 게시판 유형의 데이터가 하나의 테이블에 집중되는 정적 구조였습니다. 이를 해결하기 위해 게시판 유형별로 독립 테이블을 런타임에 생성하는 동적 게시판 구조를 설계했습니다. JPA 엔티티 매핑은 컴파일 타임에 결정되므로 런타임 동적 테이블에 적용이 불가능하고, MyBatis XML도 테이블 구조 자체가 동적이어서 정적 매핑 파일로는 대응할 수 없어, JDBC Template 기반 동적 SQL 빌더를 선택했습니다.

DynamicBoardSqlBuilder가 필드 정의 메타데이터를 기반으로 INSERT, SELECT, UPDATE, DELETE SQL을 런타임에 조합하고, NamedParameterJdbcTemplate으로 실행합니다. SQL Injection 방지를 위해 모든 컬럼명과 타입은 화이트리스트 검증을 거치며, 사용자 입력값은 파라미터 바인딩으로만 전달합니다. 테이블 분리를 통해 게시판별 데이터 규모가 관리 가능한 수준으로 유지되어 단일 테이블 20만 건 병목이 해소되었고, 각 테이블에 최적화된 인덱스를 독립 적용할 수 있게 되었습니다.

이 엔진을 통해 신규 게시판 유형 추가 시 코드 변경 없이 관리자 UI에서 필드를 정의하면 즉시 사용 가능한 게시판이 생성됩니다. 프론트엔드 테마 렌더링 엔진과 결합하여 완전한 동적 게시판 시스템을 구현했으며, Elasticsearch 색인과 연계하여 분산된 동적 테이블의 데이터를 통합 검색할 수 있는 구조를 확보했습니다.

**[비동기 감사 로깅 — 로그인 AOP에서 CRUD 전체 감사 + Redis Streams 설계]**
로그인 성공 및 실패 이력은 보안 감사의 필수 요소이지만, 로깅 로직을 인증 서비스에 직접 삽입하면 비즈니스 로직과 감사 로직이 결합됩니다. 더 나아가 콘텐츠 생성, 수정, 삭제, 권한 변경, 회원 관리 등 모든 CRUD 작업의 감사 추적이 필요했으나, 기존 로깅 유틸리티는 애플리케이션 로그(SLF4J)에만 기록하여 DB 검색이 불가능했습니다.

1단계로, LoginLogAspect가 인증 서비스의 로그인 성공 및 실패를 AOP로 감지하여, IP, 타임스탬프, 사용자 정보를 비동기 스레드 풀(core 2, max 8)로 로그인 로그 테이블에 JDBC 배치 기록합니다. 2단계(설계 완료)로, 전체 CRUD 감사를 위해 Redis Streams 기반 비동기 파이프라인을 설계했습니다. AOP 기반 감사 Aspect가 서비스 레이어의 CREATE, UPDATE, DELETE 반환을 감지하여 Redis XADD로 감사 이벤트를 발행하고, Consumer Group이 배치로 소비하여 감사 테이블에 기록하는 구조입니다. 비동기 JDBC 직접 기록 대비 Redis Streams를 선택한 이유는, CRUD 감사 이벤트는 로그인보다 빈도가 수십 배 높아 CMS DB에 직접 쓰기 부하를 주면 핵심 트랜잭션 성능에 영향을 주기 때문입니다. Redis Streams는 순서 보장, Consumer Group 배치 소비, 백프레셔를 제공하면서도 Kafka 대비 운영 복잡도가 낮습니다.

Redis Streams는 Redis 장애 시 감사 이벤트가 유실될 수 있으나, Redis AOF 영속화와 MINID 기반 트리밍으로 완화합니다. 향후 감사 데이터가 대규모로 증가하면 Kafka로 전환할 수 있도록, 이벤트 스키마(action, entityType, entityId, userId, timestamp, diff)를 Kafka 호환으로 설계해두었습니다.

**[@ExecutionTime 커스텀 어노테이션 기반 메서드 성능 측정]**
특정 API의 응답 시간이 느린 원인을 파악하려면 메서드 단위 실행 시간 측정이 필요합니다. Spring Actuator와 Micrometer로 메트릭을 수집하는 방법도 있으나, 전체 메트릭 인프라 없이 개발 단계에서 간편하게 사용할 수 있는 경량 도구가 필요했습니다.

커스텀 어노테이션과 ExecutionTimeAspect AOP를 구현하여, 어노테이션을 부착한 메서드의 실행 시간을 지정 단위(나노초, 마이크로초, 밀리초, 초)와 로그 레벨(DEBUG, INFO, WARN, ERROR)로 자동 기록합니다. 예외 발생 시에도 실행 시간을 기록하여 예외 처리 비용을 포함한 성능 분석이 가능합니다.

이 도구로 권한 해소 로직의 재귀 탐색 병목을 발견하여 응답 속도를 10배 이상 개선했습니다. 향후 Micrometer 도입 시 수집된 데이터를 Prometheus 메트릭으로 연동할 수 있습니다.

**[계층형 상속 권한 모델 — PathId 기반 조회 최적화 및 Redis 노드별 캐싱]**
메뉴 트리의 권한은 상위 노드에서 하위 노드로 상속되는 구조이므로, 특정 메뉴에 대한 권한을 해소하려면 해당 노드부터 루트까지 전체 조상 체인을 탐색해야 합니다. 기존 구조는 parent_id만 보유하여 부모를 찾으려면 재귀 쿼리가 필수였고, 메뉴 깊이가 4단계 이상인 경우 조회 시간이 200ms를 초과했습니다. 또한 메뉴 동기화 시 DFS(재귀) 방식으로 트리를 순회하여 노드 수에 비례한 개별 저장 호출이 발생하고, 코드 가독성도 떨어졌습니다.

pathId(dot path) 필드를 도입하여 메뉴의 전체 조상 경로를 문자열(예: "1.3.8")로 기록합니다. 이를 통해 조상 조회는 문자열 분할 한 번으로, 하위 노드 조회는 LIKE 접두사 쿼리 한 번으로 처리됩니다. 권한 해소 시 pathId를 분할하여 얻은 조상 ID 목록으로 단일 쿼리(findAllByMenuIds)를 수행하고, 결과를 거리(distance) 기반 TreeMap에 정렬하여 가까운 조상의 권한이 우선 적용되도록 합니다. 사용자별 권한(userIdx)이 역할 기반 권한(userLevel)보다 우선하는 이중 기준으로 해소합니다. Redis 캐싱은 전체 권한을 하나의 키에 담지 않고, 메뉴 노드별로 분리(perm:menu:{menuId})하여 캐시 적중 시 단일 GET으로 해소가 완료됩니다. 24시간 TTL에 슬라이딩 갱신을 적용하여 활성 메뉴의 캐시 유지율을 높였습니다. 메뉴 동기화는 DFS 재귀에서 BFS 레벨 순회로 전환하여, 같은 깊이의 노드를 한 번에 배치 저장(saveAll)하고 pathId를 CONCAT 쿼리로 일괄 갱신합니다. 권한 캐시 무효화 시에는 pathId 접두사로 해당 노드의 모든 하위 캐시를 cascade 삭제합니다.

그 결과, 재귀 쿼리 제거와 단일 쿼리 조상 조회로 권한 해소 쿼리 수가 75% 감소하고, Redis 노드별 캐싱으로 응답 속도가 20ms 이하로 10배 이상 개선되었습니다. BFS 전환으로 메뉴 동기화 시 DB 호출 횟수가 노드 수 비례에서 트리 깊이 비례로 줄어들고, 레벨 단위 처리 구조가 코드 가독성을 높였습니다.

**[미들웨어 파이프라인 및 운영 매뉴얼 문서화]**
프론트엔드 5계층 미들웨어는 SSR/CSR 하이브리드의 복잡한 실행 흐름을 포함하고 있어, 코드만으로는 전체 동작을 이해하기 어렵습니다. 또한 운영 환경의 Elasticsearch 초기 셋업, Nori 플러그인 설치, 배포 절차 등도 문서화가 필요했습니다.

미들웨어 문서에 5계층 미들웨어의 실행 순서, 각 미들웨어의 기능과 특징, SSR/CSR 대응 방식, 전체 설계 철학(관심사 분리, redirect loop 방지, 멀티사이트 최적화)을 기록했습니다. 운영 매뉴얼에는 Elasticsearch Nori 플러그인 설치, 인덱스 초기 셋업 API 호출, 재색인 절차, Circuit Breaker 리셋 방법을 단계별로 정리했습니다.

이 문서들은 Git 버전 관리되며, 코드 변경 시 관련 문서도 함께 업데이트하는 규칙을 수립하여 문서와 코드 간 불일치를 방지합니다.


---
 정적 자원(업로드 이미지, 로고, 메뉴 JSON 등)은 빌드 아티팩트에서 분리하여 Shared 디렉토리에 통합 관리하고, 배포 시 심링크로 연결함으로써 아티팩트 크기를 경량화하고 빌드 및 배포 시간을 단축했습니다. 개발 환경(Docker 볼륨 마운트)과 운영 환경(디스크 직접 접근) 모두 동일한 절대 경로를 참조하도록 통합하여 환경별 경로 불일치 문제를 원천 차단했습니다.
 
되며, 정적 자원 변경은 빌드 및 재배포 없이 Apache가 디스크에서 직접 서빙하여 즉시 적용됩니다. 운영 서버의 Apache에서는 Shared 디렉토리의 정적 자원에 1년 immutable 캐시를 설정하여 반복 요청 시 네트워크 비용을 제거하고 애플리케이션 서버의 정적 파일 요청 부하를 해소했습니다.